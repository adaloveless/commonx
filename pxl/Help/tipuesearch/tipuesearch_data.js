var tipuesearch = {"pages": [
     {"title": "PXL.Bitmaps", "text": " ", "tags": "", "loc": "PXL.Bitmaps.html"},
     {"title": "PXL.Bitmaps.EBitmapException", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EBitmapException.html"},
     {"title": "PXL.Bitmaps.EBitmapInvalid", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EBitmapInvalid.html"},
     {"title": "PXL.Bitmaps.EBitmapLoad", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EBitmapLoad.html"},
     {"title": "PXL.Bitmaps.EBitmapSave", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EBitmapSave.html"},
     {"title": "PXL.Bitmaps.ECanvasBeginScene", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ECanvasBeginScene.html"},
     {"title": "PXL.Bitmaps.ECanvasInitialize", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ECanvasInitialize.html"},
     {"title": "PXL.Bitmaps.EDrawableBeginScene", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableBeginScene.html"},
     {"title": "PXL.Bitmaps.EDrawableTexture", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableTexture.html"},
     {"title": "PXL.Bitmaps.EDrawableTextureClear", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableTextureClear.html"},
     {"title": "PXL.Bitmaps.EDrawableTextureCopy", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableTextureCopy.html"},
     {"title": "PXL.Bitmaps.EDrawableTextureCreate", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableTextureCreate.html"},
     {"title": "PXL.Bitmaps.EDrawableTextureInitialize", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableTextureInitialize.html"},
     {"title": "PXL.Bitmaps.EDrawableTextureRestore", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EDrawableTextureRestore.html"},
     {"title": "PXL.Bitmaps.EInvalidBitmapSize", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EInvalidBitmapSize.html"},
     {"title": "PXL.Bitmaps.EInvalidImageFormatManager", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EInvalidImageFormatManager.html"},
     {"title": "PXL.Bitmaps.EInvalidProvider", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EInvalidProvider.html"},
     {"title": "PXL.Bitmaps.ELockableTexture", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTexture.html"},
     {"title": "PXL.Bitmaps.ELockableTextureAccess", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTextureAccess.html"},
     {"title": "PXL.Bitmaps.ELockableTextureClear", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTextureClear.html"},
     {"title": "PXL.Bitmaps.ELockableTextureCopy", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTextureCopy.html"},
     {"title": "PXL.Bitmaps.ELockableTextureCreate", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTextureCreate.html"},
     {"title": "PXL.Bitmaps.ELockableTextureInitialize", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTextureInitialize.html"},
     {"title": "PXL.Bitmaps.ELockableTextureRestore", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ELockableTextureRestore.html"},
     {"title": "PXL.Bitmaps.EParentDeviceInvalid", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EParentDeviceInvalid.html"},
     {"title": "PXL.Bitmaps.EParentDeviceNull", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EParentDeviceNull.html"},
     {"title": "PXL.Bitmaps.EPixelFormatConvert", "text": " ", "tags": "", "loc": "PXL.Bitmaps.EPixelFormatConvert.html"},
     {"title": "PXL.Bitmaps.ETextureException", "text": " ", "tags": "", "loc": "PXL.Bitmaps.ETextureException.html"},
     {"title": "PXL.Bitmaps.TBitmap", "text": " system, texture, etc.) and has canvas so it can be drawn into. Bitmap operations such as resizing or storage change attempts to preserve existing data as much as possible. In contrast to many other hardware-assisted components in the framework, the methods of this class return no result type but raise exceptions when issues arise. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html"},
     {"title": "PXL.Bitmaps.TBitmap.Create", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Create"},
     {"title": "PXL.Bitmaps.TBitmap.IsEmpty", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#IsEmpty"},
     {"title": "PXL.Bitmaps.TBitmap.CanvasBeginScene", "text": " This may trigger storage range if current storage is not drawable texture.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#CanvasBeginScene"},
     {"title": "PXL.Bitmaps.TBitmap.GetRegion", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#GetRegion"},
     {"title": "PXL.Bitmaps.TBitmap.GetTexture", "text": " <code>Index</code> should always be zero as bitmap can have only one texture. This may trigger storage change if current storage has no texture support.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#GetTexture"},
     {"title": "PXL.Bitmaps.TBitmap.GetTextureCount", "text": " In this implementation, this will always return one.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#GetTextureCount"},
     {"title": "PXL.Bitmaps.TBitmap.Clear", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Clear"},
     {"title": "PXL.Bitmaps.TBitmap.CopyFrom", "text": " This ensures that current bitmap has the same size as the source. The current pixel format is not changed and if it remains unspecified before this call, it will be set to the default one. This may change bitmap storage for both source and current bitmaps depending on the currently set values to be able to reliably copy image information.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#CopyFrom"},
     {"title": "PXL.Bitmaps.TBitmap.LoadFromFile", "text": " This may change current pixel format, size and storage type. The function uses image format manager reference provided by the associated device.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#LoadFromFile"},
     {"title": "PXL.Bitmaps.TBitmap.LoadFromStream", "text": " This may change current pixel format, size and storage type. The function uses image format manager reference provided by the associated device.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#LoadFromStream"},
     {"title": "PXL.Bitmaps.TBitmap.SaveToFile", "text": " This may change current storage type. The function uses image format manager reference provided by the associated device. <code>Quality</code> parameter is a hint that may have different interpretations depending on destination file format, platform and provider; for instance, for JPEG files, on most implementations this is just a typecast integer representing image quality between 0 and 100.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#SaveToFile"},
     {"title": "PXL.Bitmaps.TBitmap.SaveToStream", "text": " This may change current storage type. The function uses image format manager reference provided by the associated device. <code>Quality</code> parameter is a hint that may have different interpretations depending on destination file format, platform and provider; for instance, for JPEG files, on most implementations this is just a typecast integer representing image quality between 0 and 100.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#SaveToStream"},
     {"title": "PXL.Bitmaps.TBitmap.SetSize", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#SetSize"},
     {"title": "PXL.Bitmaps.TBitmap.SetSize", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#SetSize"},
     {"title": "PXL.Bitmaps.TBitmap.CanvasEndScene", "text": "    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#CanvasEndScene"},
     {"title": "PXL.Bitmaps.TBitmap.ChangeStorage", "text": " If operation fails for some reason, the appropriate exception will be raised.    ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#ChangeStorage"},
     {"title": "PXL.Bitmaps.TBitmap.Canvas", "text": " This changes storage type to <code>TBitmapStorage.Drawable</code> while preserving image data. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Canvas"},
     {"title": "PXL.Bitmaps.TBitmap.Device", "text": " ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Device"},
     {"title": "PXL.Bitmaps.TBitmap.Height", "text": " Changing this preserves image contents as much as possible. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Height"},
     {"title": "PXL.Bitmaps.TBitmap.PixelFormat", "text": " Changing this preserves image contents as much as possible. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#PixelFormat"},
     {"title": "PXL.Bitmaps.TBitmap.Regions", "text": " When drawing the current bitmap to canvas, there are methods that can take region number as parameter, therefore facilitating use of image atlases or tiles. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Regions"},
     {"title": "PXL.Bitmaps.TBitmap.Size", "text": " Changing this preserves image contents as much as possible. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Size"},
     {"title": "PXL.Bitmaps.TBitmap.Storage", "text": " Changing this to a different value may create new type of resources, while releasing others, but the image data is preserved. Many operations may automatically change storage type depending on context, so this should be changed manually only when doing so can improve performance (for example, to start immediately with drawable texture instead of going through system/lockable stages). ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Storage"},
     {"title": "PXL.Bitmaps.TBitmap.Surface", "text": " This changes storage type to <code>TBitmapStorage.System</code> while preserving image data. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Surface"},
     {"title": "PXL.Bitmaps.TBitmap.Texture", "text": " If current storage type is system (which has no texture), this will change storage type to <code>TBitmapStorage.Lockable</code>. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Texture"},
     {"title": "PXL.Bitmaps.TBitmap.Width", "text": " Changing this preserves image contents as much as possible. ", "tags": "", "loc": "PXL.Bitmaps.TBitmap.html#Width"},
     {"title": "PXL.Bitmaps.TBitmapStorage", "text": "  System Image is currently stored in system memory, typically <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>.   Lockable Image is currently stored in lockable texture, typically <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html\">TCustomLockableTexture</a>.   Drawable Image is currently stored in drawable texture, typically <a class=\"normal\" href=\"PXL.Textures.TCustomDrawableTexture.html\">TCustomDrawableTexture</a>.  ", "tags": "", "loc": "PXL.Bitmaps.html#TBitmapStorage"},
     {"title": "PXL.Boards.Types", "text": " ", "tags": "", "loc": "PXL.Boards.Types.html"},
     {"title": "PXL.Boards.Types.TCustomADC", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomADC.html"},
     {"title": "PXL.Boards.Types.TCustomADC.GetRawValue", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomADC.html#GetRawValue"},
     {"title": "PXL.Boards.Types.TCustomADC.RawValue", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomADC.html#RawValue"},
     {"title": "PXL.Boards.Types.TCustomClockRTC", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomClockRTC.html"},
     {"title": "PXL.Boards.Types.TCustomClockRTC.GetValue", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomClockRTC.html#GetValue"},
     {"title": "PXL.Boards.Types.TCustomClockRTC.SetValue", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomClockRTC.html#SetValue"},
     {"title": "PXL.Boards.Types.TCustomClockRTC.Value", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomClockRTC.html#Value"},
     {"title": "PXL.Boards.Types.TCustomDataPort", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomDataPort.html"},
     {"title": "PXL.Boards.Types.TCustomDataPort.Read", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomDataPort.html#Read"},
     {"title": "PXL.Boards.Types.TCustomDataPort.Write", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomDataPort.html#Write"},
     {"title": "PXL.Boards.Types.TCustomGPIO", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html"},
     {"title": "PXL.Boards.Types.TCustomGPIO.GetPinMode", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#GetPinMode"},
     {"title": "PXL.Boards.Types.TCustomGPIO.GetPinValue", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#GetPinValue"},
     {"title": "PXL.Boards.Types.TCustomGPIO.SetMux", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#SetMux"},
     {"title": "PXL.Boards.Types.TCustomGPIO.SetPinMode", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#SetPinMode"},
     {"title": "PXL.Boards.Types.TCustomGPIO.SetPinValue", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#SetPinValue"},
     {"title": "PXL.Boards.Types.TCustomGPIO.PinMode", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#PinMode"},
     {"title": "PXL.Boards.Types.TCustomGPIO.PinValue", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomGPIO.html#PinValue"},
     {"title": "PXL.Boards.Types.TCustomPortI2C", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.ReadBlockData", "text": " Although this varies depending on implementation, but typically stop bit is given at the end of the whole transmission (so there is no stop bit between command and read operation). Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#ReadBlockData"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.ReadByte", "text": " Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#ReadByte"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.ReadByteData", "text": " Although this varies depending on implementation, but typically stop bit is given at the end of the whole transmission (so there is no stop bit between command and read operation). Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#ReadByteData"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.ReadWordData", "text": " Although this varies depending on implementation, but typically stop bit is given at the end of the whole transmission (so there is no stop bit between command and read operation). Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#ReadWordData"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.WriteBlockData", "text": " Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#WriteBlockData"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.WriteByte", "text": " Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#WriteByte"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.WriteByteData", "text": " Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#WriteByteData"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.WriteBytes", "text": " Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#WriteBytes"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.WriteWordData", "text": " Returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#WriteWordData"},
     {"title": "PXL.Boards.Types.TCustomPortI2C.SetAddress", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortI2C.html#SetAddress"},
     {"title": "PXL.Boards.Types.TCustomPortSPI", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.Transfer", "text": "      ReadBuffer Pointer to data buffer where the data will be read from. If this parameter is set to <code>Nil</code>, then no reading will be done. WriteBuffer Pointer to data buffer where the data will be written to. If this parameter is set to <code>Nil</code>, then no writing will be done. BufferSize The size of read and write buffers in bytes. Number of bytes that were actually transferred. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#Transfer"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.Transfer", "text": "     Buffer Pointer to data buffer where the data will be read from and at the same time written to, overwriting its contents. BufferSize The size of buffer in bytes. Number of bytes that were actually transferred. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#Transfer"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.GetBitsPerWord", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#GetBitsPerWord"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.GetChipSelectAttributes", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#GetChipSelectAttributes"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.GetFrequency", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#GetFrequency"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.GetMode", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#GetMode"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.SetBitsPerWord", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#SetBitsPerWord"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.SetChipSelectAttributes", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#SetChipSelectAttributes"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.SetFrequency", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#SetFrequency"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.SetMode", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#SetMode"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.BitsPerWord", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#BitsPerWord"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.ChipSelectAttributes", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#ChipSelectAttributes"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.Frequency", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#Frequency"},
     {"title": "PXL.Boards.Types.TCustomPortSPI.Mode", "text": " The actual meaning of this parameter depends on implementation and should be consulted from corresponding documentation. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortSPI.html#Mode"},
     {"title": "PXL.Boards.Types.TCustomPortUART", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html"},
     {"title": "PXL.Boards.Types.TCustomPortUART.InterimSleepTime", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#InterimSleepTime"},
     {"title": "PXL.Boards.Types.TCustomPortUART.StringBufferSize", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#StringBufferSize"},
     {"title": "PXL.Boards.Types.TCustomPortUART.ReadBuffer", "text": "      Buffer Pointer to data buffer where the data will be written to. BufferSize Number of bytes to read. Timeout Maximum time (in milliseconds) to wait while attempting to read the buffer. If this parameter is set to zero, then the function will read only as much data as fits in readable FIFO buffers (or none when such buffers are not supported). Number of bytes that were actually read. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#ReadBuffer"},
     {"title": "PXL.Boards.Types.TCustomPortUART.ReadByte", "text": " <code>Timeout</code> defines maximum time (in milliseconds) to wait while attempting to do so; if this parameter is set to zero, then the function will read only what's in readable FIFO buffers or fail when such buffers are unavailable. <code>True</code> is returned when the operation was successful and <code>False</code> when the byte could not be read.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#ReadByte"},
     {"title": "PXL.Boards.Types.TCustomPortUART.ReadString", "text": "      Text String that will hold the incoming data. MaxCharacters Maximum number of characters to read. Once this number of characters has been read, the function immediately returns, even if there is more data to read. When this parameter is set to zero, then the function will continue to read the data, depending on value of <code>Timeout</code>. Timeout Maximum time (in milliseconds) to wait while attempting to read the buffer. If this parameter is set to zero, then the function will read only as much data as fits in readable FIFO buffers (or fail when such buffers are not supported). Number of bytes that were actually read. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#ReadString"},
     {"title": "PXL.Boards.Types.TCustomPortUART.WriteBuffer", "text": "      Buffer Pointer to data buffer where the data will be read from. BufferSize Number of bytes to write. Timeout Maximum time (in milliseconds) to wait while attempting to write the buffer. If this parameter is set to zero, then the function will write only as much data as fits in writable FIFO buffers (or none when such buffers are not supported). Number of bytes that were actually written. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#WriteBuffer"},
     {"title": "PXL.Boards.Types.TCustomPortUART.WriteByte", "text": " <code>Timeout</code> defines maximum time (in milliseconds) to wait while attempting to do so; if this parameter is set to zero, then the function will write only what fits in writable FIFO buffers or fail when such buffers are unavailable. <code>True</code> is returned when the operation was successful and <code>False</code> when the byte could not be written.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#WriteByte"},
     {"title": "PXL.Boards.Types.TCustomPortUART.WriteBytes", "text": " <code>Timeout</code> defines maximum time (in milliseconds) to wait while attempting to do so; if this parameter is set to zero, then the function will write only what fits in writable FIFO buffers or fail when such buffers are unavailable. <code>True</code> is returned when the operation was successful and <code>False</code> when not all bytes could be written.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#WriteBytes"},
     {"title": "PXL.Boards.Types.TCustomPortUART.WriteString", "text": "     Text String that should be sent. Timeout Maximum time (in milliseconds) to wait while attempting to write the buffer. If this parameter is set to zero, then the function will write only what fits in writable FIFO buffers (or fail when such buffers are not supported). Number of bytes that were actually read. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#WriteString"},
     {"title": "PXL.Boards.Types.TCustomPortUART.GetBaudRate", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#GetBaudRate"},
     {"title": "PXL.Boards.Types.TCustomPortUART.GetBitsPerWord", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#GetBitsPerWord"},
     {"title": "PXL.Boards.Types.TCustomPortUART.GetParity", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#GetParity"},
     {"title": "PXL.Boards.Types.TCustomPortUART.GetStopBits", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#GetStopBits"},
     {"title": "PXL.Boards.Types.TCustomPortUART.Flush", "text": " The actual meaning of this may depend on implementation - it could mean that the buffers are simply emptied or any buffers that are waiting due to packetization are sent immediately.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#Flush"},
     {"title": "PXL.Boards.Types.TCustomPortUART.SetBaudRate", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#SetBaudRate"},
     {"title": "PXL.Boards.Types.TCustomPortUART.SetBitsPerWord", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#SetBitsPerWord"},
     {"title": "PXL.Boards.Types.TCustomPortUART.SetParity", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#SetParity"},
     {"title": "PXL.Boards.Types.TCustomPortUART.SetStopBits", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#SetStopBits"},
     {"title": "PXL.Boards.Types.TCustomPortUART.BaudRate", "text": " Note that to calculate the actual speed of transmission, it is necessary to take into account start and stop bits among other things; for typical situations, the actual transmission speed may be something like BaudRate / 10 bytes per second or less. ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#BaudRate"},
     {"title": "PXL.Boards.Types.TCustomPortUART.BitsPerWord", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#BitsPerWord"},
     {"title": "PXL.Boards.Types.TCustomPortUART.Parity", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#Parity"},
     {"title": "PXL.Boards.Types.TCustomPortUART.StopBits", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPortUART.html#StopBits"},
     {"title": "PXL.Boards.Types.TCustomPWM", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html"},
     {"title": "PXL.Boards.Types.TCustomPWM.GetDutyCycle", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#GetDutyCycle"},
     {"title": "PXL.Boards.Types.TCustomPWM.GetEnabled", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#GetEnabled"},
     {"title": "PXL.Boards.Types.TCustomPWM.GetPeriod", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#GetPeriod"},
     {"title": "PXL.Boards.Types.TCustomPWM.Start", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#Start"},
     {"title": "PXL.Boards.Types.TCustomPWM.Stop", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#Stop"},
     {"title": "PXL.Boards.Types.TCustomPWM.SetDutyCycle", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#SetDutyCycle"},
     {"title": "PXL.Boards.Types.TCustomPWM.SetEnabled", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#SetEnabled"},
     {"title": "PXL.Boards.Types.TCustomPWM.SetPeriod", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#SetPeriod"},
     {"title": "PXL.Boards.Types.TCustomPWM.DutyCycle", "text": " 500000 ns for period of 1000000 ns would define a 50% of duty cycle). ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#DutyCycle"},
     {"title": "PXL.Boards.Types.TCustomPWM.Enabled", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#Enabled"},
     {"title": "PXL.Boards.Types.TCustomPWM.Period", "text": " 1000000 ns period would be 1 ms or 100 hz). ", "tags": "", "loc": "PXL.Boards.Types.TCustomPWM.html#Period"},
     {"title": "PXL.Boards.Types.TCustomSystemCore", "text": " ", "tags": "", "loc": "PXL.Boards.Types.TCustomSystemCore.html"},
     {"title": "PXL.Boards.Types.TCustomSystemCore.GetTickCount", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomSystemCore.html#GetTickCount"},
     {"title": "PXL.Boards.Types.TCustomSystemCore.TicksInBetween", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomSystemCore.html#TicksInBetween"},
     {"title": "PXL.Boards.Types.TCustomSystemCore.BusyWait", "text": " This is useful for accurate timing but may result in high CPU usage.    ", "tags": "", "loc": "PXL.Boards.Types.TCustomSystemCore.html#BusyWait"},
     {"title": "PXL.Boards.Types.TCustomSystemCore.Delay", "text": "    ", "tags": "", "loc": "PXL.Boards.Types.TCustomSystemCore.html#Delay"},
     {"title": "PXL.Boards.Types.MaxI2CTransferSize", "text": " ", "tags": "", "loc": "PXL.Boards.Types.html#MaxI2CTransferSize"},
     {"title": "PXL.Boards.Types.MaxSPITransferSize", "text": " ", "tags": "", "loc": "PXL.Boards.Types.html#MaxSPITransferSize"},
     {"title": "PXL.Boards.Types.TChipSelectAttribute", "text": "  ActiveHigh Chip Select should be held active high instead of active low.   Disable Chip Select should be disabled.  ", "tags": "", "loc": "PXL.Boards.Types.html#TChipSelectAttribute"},
     {"title": "PXL.Boards.Types.TChipSelectAttributes", "text": " ", "tags": "", "loc": "PXL.Boards.Types.html#TChipSelectAttributes"},
     {"title": "PXL.Boards.Types.TParity", "text": "  None No parity bit.   Odd Odd parity bit.   Even Even parity bit.  ", "tags": "", "loc": "PXL.Boards.Types.html#TParity"},
     {"title": "PXL.Boards.Types.TPinMode", "text": "  Input Pin set for input / high impedance   Output Pin set for output  ", "tags": "", "loc": "PXL.Boards.Types.html#TPinMode"},
     {"title": "PXL.Boards.Types.TPinValue", "text": "  Low Low (0) or zero voltage.   High High (1) or full voltage.  ", "tags": "", "loc": "PXL.Boards.Types.html#TPinValue"},
     {"title": "PXL.Boards.Types.TStopBits", "text": "  One One stop bit.   OneDotFive One and &quot;half&quot; stop bits.   Two Two stop bits.  ", "tags": "", "loc": "PXL.Boards.Types.html#TStopBits"},
     {"title": "PXL.Canvas", "text": " ", "tags": "", "loc": "PXL.Canvas.html"},
     {"title": "PXL.Canvas.TCustomCanvas", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html"},
     {"title": "PXL.Canvas.TCustomCanvas.FCurrentPremultipliedAlpha", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FCurrentPremultipliedAlpha"},
     {"title": "PXL.Canvas.TCustomCanvas.FCurrentTexture", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FCurrentTexture"},
     {"title": "PXL.Canvas.TCustomCanvas.FCurrentTextureMapping", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FCurrentTextureMapping"},
     {"title": "PXL.Canvas.TCustomCanvas.Create", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Create"},
     {"title": "PXL.Canvas.TCustomCanvas.BeginScene", "text": " Any rendering calls can be made after this method succeeds. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#BeginScene"},
     {"title": "PXL.Canvas.TCustomCanvas.Initialize", "text": " Note that for actual rendering to take place, <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#BeginScene\">BeginScene</a> needs to be called first, assuming that initialization succeeded. This results <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Initialize"},
     {"title": "PXL.Canvas.TCustomCanvas.SetEffect", "text": " This functionality may be provider and platform dependent. Also, for this to work, <i>TCanvasAttribute.CustomEffect</i> should be set in <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#Attributes\">Attributes</a>.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#SetEffect"},
     {"title": "PXL.Canvas.TCustomCanvas.SetPalette", "text": " Support for such images varies depending on provider and platform. This returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#SetPalette"},
     {"title": "PXL.Canvas.TCustomCanvas.BeginDraw", "text": " Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#BeginDraw"},
     {"title": "PXL.Canvas.TCustomCanvas.DeviceRestore", "text": " This may be implemented by derived classes to handle &quot;device lost&quot; scenario.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#DeviceRestore"},
     {"title": "PXL.Canvas.TCustomCanvas.GetClipRect", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#GetClipRect"},
     {"title": "PXL.Canvas.TCustomCanvas.InitCanvas", "text": " Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#InitCanvas"},
     {"title": "PXL.Canvas.TCustomCanvas.NeedsInitialization", "text": " When this method returns <code>False</code>, then the canvas becomes initialized at the creation and cannot be &quot;finalized&quot;.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#NeedsInitialization"},
     {"title": "PXL.Canvas.TCustomCanvas.Circle", "text": " This function uses <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#Line\">Line</a> primitive. <code>Steps</code> parameter indicates number of divisions in the ellipse. <code>UseWuLines</code> determines whether to use <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#WuLine\">WuLine</a> primitive instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Circle"},
     {"title": "PXL.Canvas.TCustomCanvas.DrawIndexedTriangles", "text": " This method is considered basic functionality and should always be implemented by derived classes.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#DrawIndexedTriangles"},
     {"title": "PXL.Canvas.TCustomCanvas.DrawTexturedTriangles", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#DrawTexturedTriangles"},
     {"title": "PXL.Canvas.TCustomCanvas.Ellipse", "text": " This function uses <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#Line\">Line</a> primitive. <code>Steps</code> parameter indicates number of divisions in the ellipse. <code>UseWuLines</code> indicates whether to use <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#WuLine\">WuLine</a> primitive instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Ellipse"},
     {"title": "PXL.Canvas.TCustomCanvas.EndScene", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#EndScene"},
     {"title": "PXL.Canvas.TCustomCanvas.FillArc", "text": " The arc begins at <code>InitAngle</code> and ends at <code>EndAngle</code> (in radians), subdivided into a number of triangles specified in <code>Steps</code>. The arc's shape is filled with four color gradient.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillArc"},
     {"title": "PXL.Canvas.TCustomCanvas.FillArc", "text": " The arc begins at <code>InitAngle</code> and ends at <code>EndAngle</code> (in radians), subdivided into a number of triangles specified in <code>Steps</code>. The arc's shape is filled with four color gradient.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillArc"},
     {"title": "PXL.Canvas.TCustomCanvas.FillCircle", "text": " The circle is subdivided into a number of triangles specified in <code>Steps</code>. The shape of circle is filled with four color gradient.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillCircle"},
     {"title": "PXL.Canvas.TCustomCanvas.FillEllipse", "text": " The ellipse is subdivided into a number of triangles specified in <code>Steps</code>. The shape of ellipse is filled with four color gradient.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillEllipse"},
     {"title": "PXL.Canvas.TCustomCanvas.FillHexagon", "text": " The size, position and rotation of hexagon can be given using one or a combination of several 3x3 matrices multiplied together.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillHexagon"},
     {"title": "PXL.Canvas.TCustomCanvas.FillQuad", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillQuad"},
     {"title": "PXL.Canvas.TCustomCanvas.FillRect", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillRect"},
     {"title": "PXL.Canvas.TCustomCanvas.FillRect", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillRect"},
     {"title": "PXL.Canvas.TCustomCanvas.FillRect", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillRect"},
     {"title": "PXL.Canvas.TCustomCanvas.FillRibbon", "text": " The ribbon begins at <code>InitAngle</code> and ends at <code>EndAngle</code> (in radians), subdivided into a number of triangles specified in <code>Steps</code>. The ribbon's shape is filled with four color gradient.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillRibbon"},
     {"title": "PXL.Canvas.TCustomCanvas.FillRibbon", "text": " The ribbon begins at <code>InitAngle</code> and ends at <code>EndAngle</code> (in radians), subdivided into a number of triangles specified in <code>Steps</code>. The ribbon's shape is filled with continuous gradient set by three pairs of inner and outer colors.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillRibbon"},
     {"title": "PXL.Canvas.TCustomCanvas.FillTri", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FillTri"},
     {"title": "PXL.Canvas.TCustomCanvas.Finalize", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Finalize"},
     {"title": "PXL.Canvas.TCustomCanvas.Flush", "text": " This can be useful to make sure that nothing remains in canvas cache before starting to render, for instance, a 3D scene.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Flush"},
     {"title": "PXL.Canvas.TCustomCanvas.FrameRect", "text": " Although this may receive coordinates for shapes other than rectangle (for example, quadrilateral), the result may be unpredictable. This method unlike other line drawing methods uses filled shapes and assumes that four vertices are aligned to form rectangle. The produced result respects last pixel rule and can be used for drawing UI elements (whereas methods like <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#WireQuad\">WireQuad</a> may produce incorrectly sized rectangles depending on implementation).    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FrameRect"},
     {"title": "PXL.Canvas.TCustomCanvas.FrameRect", "text": " This works in similar fashion as other overloaded <i>FrameRect</i> method by drawing filled shapes instead of lines, and is meant for rendering UI elements.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#FrameRect"},
     {"title": "PXL.Canvas.TCustomCanvas.HorizLine", "text": " This method uses filled shapes instead of actual lines to produce accurate results and is meant for rendering UI elements.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#HorizLine"},
     {"title": "PXL.Canvas.TCustomCanvas.HorizLine", "text": " This method uses filled shapes instead of actual lines to produce accurate results and is meant for rendering UI elements.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#HorizLine"},
     {"title": "PXL.Canvas.TCustomCanvas.Line", "text": " This method is considered basic functionality and should always be implemented by derived classes.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Line"},
     {"title": "PXL.Canvas.TCustomCanvas.Line", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Line"},
     {"title": "PXL.Canvas.TCustomCanvas.Line", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Line"},
     {"title": "PXL.Canvas.TCustomCanvas.Line", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Line"},
     {"title": "PXL.Canvas.TCustomCanvas.LineArray", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#LineArray"},
     {"title": "PXL.Canvas.TCustomCanvas.PutPixel", "text": " This method is considered basic functionality and should always be implemented by derived classes.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#PutPixel"},
     {"title": "PXL.Canvas.TCustomCanvas.PutPixel", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#PutPixel"},
     {"title": "PXL.Canvas.TCustomCanvas.QuadHole", "text": " The quality of the hole is defined by the value of <code>Steps</code> in number of subdivisions. This entire shape is filled with gradient starting from outer color at the edges of rectangle and inner color ending at the edge of hole. This shape can be particularly useful for highlighting items on the screen by darkening the entire area except the one inside the hole.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#QuadHole"},
     {"title": "PXL.Canvas.TCustomCanvas.Reset", "text": " This can be useful when custom state changes have been made (for instance, in a 3D scene) so to restore the canvas to its working condition this method should be called.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Reset"},
     {"title": "PXL.Canvas.TCustomCanvas.ResetPalette", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#ResetPalette"},
     {"title": "PXL.Canvas.TCustomCanvas.TexQuad", "text": " The texture must be set prior to this call by one of <code>UseTexture[...]</code> or <code>UseImage[...]</code> calls. For every call of <code>TexQuad</code> there must be a preceding <code>UseTexture[...]</code> or <code>UseImage[...]</code> call to specify the image or texture. All pixels of the rendered texture are multiplied by the gradient color before applying alpha-blending. If the texture has no alpha-channel present, alpha value of the gradient will be used instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#TexQuad"},
     {"title": "PXL.Canvas.TCustomCanvas.UseImage", "text": " The coordinates inside the texture are defined in logical units in range of [0..1].    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseImage"},
     {"title": "PXL.Canvas.TCustomCanvas.UseImage", "text": " If the image has multiple textures, then the first one will be used.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseImage"},
     {"title": "PXL.Canvas.TCustomCanvas.UseImagePx", "text": " The coordinates inside the texture are defined in pixels using floating-point coordinates.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseImagePx"},
     {"title": "PXL.Canvas.TCustomCanvas.UseImageRegion", "text": " That region can also be mirrored horizontally and/or flipped vertically, if needed. If the image has no or just one pattern, the value of <code>Region</code> should be set to zero; in this case, the entire texture is used instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseImageRegion"},
     {"title": "PXL.Canvas.TCustomCanvas.UseImageRegion", "text": " Only a certain portion of that region is used for rendering defined by the given coordinates; these coordinates can also be mirrored horizontally and/or flipped vertically, if needed. If the image has no or just one pattern, the value of <code>Region</code> should be set to zero; in this case, the entire texture is used instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseImageRegion"},
     {"title": "PXL.Canvas.TCustomCanvas.UseImageRegion", "text": " If the image has none or just one region defined, the value of <code>Region</code> should be set to zero; in this case, the entire texture is used instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseImageRegion"},
     {"title": "PXL.Canvas.TCustomCanvas.UseTexture", "text": " The coordinates inside the texture are defined in logical units in range of [0..1].    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseTexture"},
     {"title": "PXL.Canvas.TCustomCanvas.UseTexturePx", "text": " The coordinates inside the texture are defined in pixels using floating-point coordinates.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UseTexturePx"},
     {"title": "PXL.Canvas.TCustomCanvas.VertLine", "text": " This method uses filled shapes instead of actual lines to produce accurate results and is meant for rendering UI elements.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#VertLine"},
     {"title": "PXL.Canvas.TCustomCanvas.VertLine", "text": " This method uses filled shapes instead of actual lines to produce accurate results and is meant for rendering UI elements.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#VertLine"},
     {"title": "PXL.Canvas.TCustomCanvas.WireHexagon", "text": " The vertices are spaced 0.5 pixels apart from its center (so diameter is 1) in all directions, multiplied by the given matrix and filled with gradient of six colors at the corresponding vertices. The size, position and rotation of hexagon can be given using one or a combination of several 3x3 matrices multiplied together. This method uses <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#Line\">Line</a> primitive. <code>UseWuLines</code> determines whether to use <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#WuLine\">WuLine</a> primitive instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#WireHexagon"},
     {"title": "PXL.Canvas.TCustomCanvas.WireQuad", "text": " Note that this may not necessarily respect last pixel rendering rule). This method uses <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#Line\">Line</a> primitive. <code>UseWuLines</code> determines whether to use <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#WuLine\">WuLine</a> primitive instead.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#WireQuad"},
     {"title": "PXL.Canvas.TCustomCanvas.WuLine", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#WuLine"},
     {"title": "PXL.Canvas.TCustomCanvas.DeviceRelease", "text": " This may be implemented by derived classes to handle &quot;device lost&quot; scenario.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#DeviceRelease"},
     {"title": "PXL.Canvas.TCustomCanvas.DoneCanvas", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#DoneCanvas"},
     {"title": "PXL.Canvas.TCustomCanvas.EndDraw", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#EndDraw"},
     {"title": "PXL.Canvas.TCustomCanvas.NextDrawCall", "text": " Basically, this increments <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#CacheStall\">CacheStall</a> by one, which by default is reset back to zero after call to <a class=\"normal\" href=\"PXL.Canvas.TCustomCanvas.html#BeginScene\">BeginScene</a>.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#NextDrawCall"},
     {"title": "PXL.Canvas.TCustomCanvas.SetClipRect", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#SetClipRect"},
     {"title": "PXL.Canvas.TCustomCanvas.UpdateAttributes", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#UpdateAttributes"},
     {"title": "PXL.Canvas.TCustomCanvas.Attributes", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Attributes"},
     {"title": "PXL.Canvas.TCustomCanvas.CacheStall", "text": " Each cache reset is typically a time-consuming operation so high number of such events could be detrimental to the application's rendering performance. If this parameter happens to be considerably high in the rendered scene, the rendering code should be revised for better grouping of images, shapes and blending types. ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#CacheStall"},
     {"title": "PXL.Canvas.TCustomCanvas.ClipRect", "text": " This can be useful for restricting the rendering to a certain portion of surface. ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#ClipRect"},
     {"title": "PXL.Canvas.TCustomCanvas.Device", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Device"},
     {"title": "PXL.Canvas.TCustomCanvas.Initialized", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Initialized"},
     {"title": "PXL.Canvas.TCustomCanvas.Parent", "text": " ", "tags": "", "loc": "PXL.Canvas.TCustomCanvas.html#Parent"},
     {"title": "PXL.Canvas.TCustomCanvasEffect", "text": " The actual implementation varies depending on provider and platform. ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasEffect.html"},
     {"title": "PXL.Canvas.TCustomCanvasImage", "text": " This provides methods that are called by canvas to obtain minimal information about textures and regions. ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasImage.html"},
     {"title": "PXL.Canvas.TCustomCanvasImage.GetRegion", "text": " These regions are also called &quot;patterns&quot; or &quot;tiles&quot; in different media.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasImage.html#GetRegion"},
     {"title": "PXL.Canvas.TCustomCanvasImage.GetTexture", "text": " If the index is outside of valid range, this should return <code>Nil</code>.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasImage.html#GetTexture"},
     {"title": "PXL.Canvas.TCustomCanvasImage.GetTextureCount", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasImage.html#GetTextureCount"},
     {"title": "PXL.Canvas.TCustomCanvasParent", "text": " Basically, this is an object that can own canvas internally and have functions that are executed along with canvas's <i>BeginScene</i> and <i>EndScene</i> calls. ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasParent.html"},
     {"title": "PXL.Canvas.TCustomCanvasParent.CanvasBeginScene", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasParent.html#CanvasBeginScene"},
     {"title": "PXL.Canvas.TCustomCanvasParent.CanvasInternalBeginScene", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasParent.html#CanvasInternalBeginScene"},
     {"title": "PXL.Canvas.TCustomCanvasParent.CanvasEndScene", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasParent.html#CanvasEndScene"},
     {"title": "PXL.Canvas.TCustomCanvasParent.CanvasInternalEndScene", "text": "    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasParent.html#CanvasInternalEndScene"},
     {"title": "PXL.Canvas.TCustomCanvasParent.SetCanvasParent", "text": " This method is the only way to change <i>TCanvas.Parent</i> attribute.    ", "tags": "", "loc": "PXL.Canvas.TCustomCanvasParent.html#SetCanvasParent"},
     {"title": "PXL.Canvas.TBlendingEffect", "text": "  Unknown Undefined blending effect.  This means that blending effect has not been defined - this is used internally and should not be used otherwise. <br> <br>  None Blending effect disabled.  In this case, drawing operation is just copy operation.  Normal Normal blending effect.  If drawing primitive has alpha-channel supplied, it will be alpha-blended to the destination depending on source alpha values. <br> <br>  Shadow Shadow drawing effect.  The destination surface will be multiplied by alpha-channel of the source primitive; thus, the rendered image will look like a shadow. <br> <br>  Add Additive blending effect.  The source primitive will be multiplied by its alpha-channel and then added to the destination with saturation. <br> <br>  Multiply Multiplication blending effect.  The destination surface will be multiplied by the source primitive. <br> <br>  InverseMultiply Inverse multiplication effect.  The destination surface will be multiplied by an inverse of the source primitive. <br> <br>  SourceColor Source color blending effect.  Instead of using alpha-channel, the grayscale value of source primitive's pixels will be used as an alpha value for blending on destination. <br> <br>  SourceColorAdd Source color additive blending effect.  Instead of using alpha-channel, the grayscale value of source primitive's pixels will be used as an alpha value for multiplying source pixels, which will then be added to destination with saturation. <br> <br> ", "tags": "", "loc": "PXL.Canvas.html#TBlendingEffect"},
     {"title": "PXL.Canvas.TCanvasAttribute", "text": "  Antialias Antialiasing should be used when rendering images.  For typical implementations this means that bilinear filtering will be used when interpolating image pixels.  MipMapping Mipmapping should be used when rendering images.  If this attribute is not included, then mipmapping will be disabled even if the image to be rendered contains mipmaps.  CustomEffect Custom shader effect will be used when rendering images.  This effect needs to be set and configured prior drawing. ", "tags": "", "loc": "PXL.Canvas.html#TCanvasAttribute"},
     {"title": "PXL.Canvas.TCanvasAttributes", "text": " ", "tags": "", "loc": "PXL.Canvas.html#TCanvasAttributes"},
     {"title": "PXL.Classes", "text": " ", "tags": "", "loc": "PXL.Classes.html"},
     {"title": "PXL.Classes.TAssetStream", "text": " This stream serves no purpose on other platforms. ", "tags": "", "loc": "PXL.Classes.TAssetStream.html"},
     {"title": "PXL.Classes.TAssetStream.Create", "text": "    ", "tags": "", "loc": "PXL.Classes.TAssetStream.html#Create"},
     {"title": "PXL.Classes.TAssetStream.FileName", "text": " ", "tags": "", "loc": "PXL.Classes.TAssetStream.html#FileName"},
     {"title": "PXL.Classes.TStreamHelper", "text": " Although TStream in recent versions of FPC and Delphi introduced similar functions, this extension class provides a more comprehensive and unified set of functions that work across all platforms. ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html"},
     {"title": "PXL.Classes.TStreamHelper.GetByte", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetByte"},
     {"title": "PXL.Classes.TStreamHelper.GetByteBool", "text": " The resulting value is treated as 8-bit unsigned integer with values of [0..127] considered as <code>True</code> and values of [128..255] considered as <code>False</code>.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetByteBool"},
     {"title": "PXL.Classes.TStreamHelper.GetByteIndex", "text": " The range of returned values is [0..254], the value of 255 is returned as -1.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetByteIndex"},
     {"title": "PXL.Classes.TStreamHelper.GetBytePoint2px", "text": " Each coordinate is loaded as 8-bit unsigned integer.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetBytePoint2px"},
     {"title": "PXL.Classes.TStreamHelper.GetDouble", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetDouble"},
     {"title": "PXL.Classes.TStreamHelper.GetFloat34", "text": " The possible values are in [-8..7.9375] range.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetFloat34"},
     {"title": "PXL.Classes.TStreamHelper.GetFloat43", "text": " The possible values are in [-16..15.875] range.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetFloat43"},
     {"title": "PXL.Classes.TStreamHelper.GetInt64", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetInt64"},
     {"title": "PXL.Classes.TStreamHelper.GetLongInt", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetLongInt"},
     {"title": "PXL.Classes.TStreamHelper.GetLongPoint2px", "text": " Each coordinate is loaded as 32-bit signed integer.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetLongPoint2px"},
     {"title": "PXL.Classes.TStreamHelper.GetLongString", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetLongString"},
     {"title": "PXL.Classes.TStreamHelper.GetLongWord", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetLongWord"},
     {"title": "PXL.Classes.TStreamHelper.GetMediumString", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetMediumString"},
     {"title": "PXL.Classes.TStreamHelper.GetShortInt", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetShortInt"},
     {"title": "PXL.Classes.TStreamHelper.GetShortString", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetShortString"},
     {"title": "PXL.Classes.TStreamHelper.GetSingle", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetSingle"},
     {"title": "PXL.Classes.TStreamHelper.GetSmallInt", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetSmallInt"},
     {"title": "PXL.Classes.TStreamHelper.GetUInt64", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetUInt64"},
     {"title": "PXL.Classes.TStreamHelper.GetWord", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetWord"},
     {"title": "PXL.Classes.TStreamHelper.GetWordIndex", "text": " The range of returned values is [0..65534], the value of 65535 is returned as -1.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetWordIndex"},
     {"title": "PXL.Classes.TStreamHelper.GetWordPoint2px", "text": " Each coordinate is loaded as 16-bit unsigned integer.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetWordPoint2px"},
     {"title": "PXL.Classes.TStreamHelper.GetFloats3311", "text": " The possible values are in [-4..3.5] range.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetFloats3311"},
     {"title": "PXL.Classes.TStreamHelper.GetFloats44", "text": " The possible values are in [-8..7] range.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#GetFloats44"},
     {"title": "PXL.Classes.TStreamHelper.PutByte", "text": " If the value is outside of [0..255] range, it will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutByte"},
     {"title": "PXL.Classes.TStreamHelper.PutByteBool", "text": " A value of <code>False</code> is saved as 255, while <code>True</code> is saved as 0.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutByteBool"},
     {"title": "PXL.Classes.TStreamHelper.PutByteIndex", "text": " A value of -1 (and other negative values) is stored as 255. Positive numbers that are outside of [0..254] range will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutByteIndex"},
     {"title": "PXL.Classes.TStreamHelper.PutBytePoint2px", "text": " Each coordinate is saved as 8-bit unsigned integer.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutBytePoint2px"},
     {"title": "PXL.Classes.TStreamHelper.PutDouble", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutDouble"},
     {"title": "PXL.Classes.TStreamHelper.PutFloat34", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutFloat34"},
     {"title": "PXL.Classes.TStreamHelper.PutFloat43", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutFloat43"},
     {"title": "PXL.Classes.TStreamHelper.PutFloats3311", "text": " Values outside of [-4..3.5] range will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutFloats3311"},
     {"title": "PXL.Classes.TStreamHelper.PutFloats44", "text": " Values outside of [-8..7] range will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutFloats44"},
     {"title": "PXL.Classes.TStreamHelper.PutInt64", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutInt64"},
     {"title": "PXL.Classes.TStreamHelper.PutLongInt", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutLongInt"},
     {"title": "PXL.Classes.TStreamHelper.PutLongPoint2px", "text": " Each coordinate is saved as 32-bit signed integer.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutLongPoint2px"},
     {"title": "PXL.Classes.TStreamHelper.PutLongString", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutLongString"},
     {"title": "PXL.Classes.TStreamHelper.PutLongWord", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutLongWord"},
     {"title": "PXL.Classes.TStreamHelper.PutMediumString", "text": " The resulting UTF-8 string is limited to a maximum of 65535 characters; therefore, for certain charsets the actual string is limited to either 32767 or even 21845 characters in worst case. If MaxCount is not zero, the input string will be limited to the given number of characters.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutMediumString"},
     {"title": "PXL.Classes.TStreamHelper.PutShortInt", "text": " If the value is outside of [-128..127] range, it will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutShortInt"},
     {"title": "PXL.Classes.TStreamHelper.PutShortString", "text": " The resulting UTF-8 string is limited to a maximum of 255 characters; therefore, for certain charsets the actual string is limited to either 127 or even 85 characters in worst case. If MaxCount is not zero, the input string will be limited to the given number of characters.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutShortString"},
     {"title": "PXL.Classes.TStreamHelper.PutSingle", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutSingle"},
     {"title": "PXL.Classes.TStreamHelper.PutSmallInt", "text": " If the value is outside of [-32768..32767] range, it will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutSmallInt"},
     {"title": "PXL.Classes.TStreamHelper.PutUInt64", "text": "    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutUInt64"},
     {"title": "PXL.Classes.TStreamHelper.PutWord", "text": " If the value is outside of [0..65535] range, it will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutWord"},
     {"title": "PXL.Classes.TStreamHelper.PutWordIndex", "text": " A value of -1 (and other negative values) is stored as 65535. Positive numbers that are outside of [0..65534] range will be clamped.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutWordIndex"},
     {"title": "PXL.Classes.TStreamHelper.PutWordPoint2px", "text": " Each coordinate is saved as 16-bit unsigned integer.    ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#PutWordPoint2px"},
     {"title": "PXL.Classes.TStreamHelper.TStreamByte", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamByte"},
     {"title": "PXL.Classes.TStreamHelper.TStreamByteBool", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamByteBool"},
     {"title": "PXL.Classes.TStreamHelper.TStreamByteIndex", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamByteIndex"},
     {"title": "PXL.Classes.TStreamHelper.TStreamDouble", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamDouble"},
     {"title": "PXL.Classes.TStreamHelper.TStreamInt64", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamInt64"},
     {"title": "PXL.Classes.TStreamHelper.TStreamLongInt", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamLongInt"},
     {"title": "PXL.Classes.TStreamHelper.TStreamLongWord", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamLongWord"},
     {"title": "PXL.Classes.TStreamHelper.TStreamShortInt", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamShortInt"},
     {"title": "PXL.Classes.TStreamHelper.TStreamSingle", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamSingle"},
     {"title": "PXL.Classes.TStreamHelper.TStreamSmallInt", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamSmallInt"},
     {"title": "PXL.Classes.TStreamHelper.TStreamUInt64", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamUInt64"},
     {"title": "PXL.Classes.TStreamHelper.TStreamWord", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamWord"},
     {"title": "PXL.Classes.TStreamHelper.TStreamWordIndex", "text": " ", "tags": "", "loc": "PXL.Classes.TStreamHelper.html#TStreamWordIndex"},
     {"title": "PXL.Classes.CrossFixFileName", "text": " This calls makes sure that the provided path uses correct path delimiter.    ", "tags": "", "loc": "PXL.Classes.html#CrossFixFileName"},
     {"title": "PXL.Data", "text": " ", "tags": "", "loc": "PXL.Data.html"},
     {"title": "PXL.Data.TCipherBlock", "text": " ", "tags": "", "loc": "PXL.Data.TCipherBlock.html"},
     {"title": "PXL.Data.TCipherBlock.ByteValues", "text": " ", "tags": "", "loc": "PXL.Data.TCipherBlock.html#ByteValues"},
     {"title": "PXL.Data.TCipherBlock.WordValues", "text": " ", "tags": "", "loc": "PXL.Data.TCipherBlock.html#WordValues"},
     {"title": "PXL.Data.TCipherBlock.Values", "text": " ", "tags": "", "loc": "PXL.Data.TCipherBlock.html#Values"},
     {"title": "PXL.Data.TCipherBlock.LongValue", "text": " ", "tags": "", "loc": "PXL.Data.TCipherBlock.html#LongValue"},
     {"title": "PXL.Data.TCipherBlock.Burn", "text": "    ", "tags": "", "loc": "PXL.Data.TCipherBlock.html#Burn"},
     {"title": "PXL.Data.TCipherBlock.Init", "text": "    ", "tags": "", "loc": "PXL.Data.TCipherBlock.html#Init"},
     {"title": "PXL.Data.TCipherKey", "text": " ", "tags": "", "loc": "PXL.Data.TCipherKey.html"},
     {"title": "PXL.Data.TCipherKey.ByteValues", "text": " ", "tags": "", "loc": "PXL.Data.TCipherKey.html#ByteValues"},
     {"title": "PXL.Data.TCipherKey.WordValues", "text": " ", "tags": "", "loc": "PXL.Data.TCipherKey.html#WordValues"},
     {"title": "PXL.Data.TCipherKey.Values", "text": " ", "tags": "", "loc": "PXL.Data.TCipherKey.html#Values"},
     {"title": "PXL.Data.TCipherKey.LongValues", "text": " ", "tags": "", "loc": "PXL.Data.TCipherKey.html#LongValues"},
     {"title": "PXL.Data.TCipherKey.Burn", "text": "    ", "tags": "", "loc": "PXL.Data.TCipherKey.html#Burn"},
     {"title": "PXL.Data.TCipherKey.Init", "text": "    ", "tags": "", "loc": "PXL.Data.TCipherKey.html#Init"},
     {"title": "PXL.Data.TMD5Checksum", "text": " ", "tags": "", "loc": "PXL.Data.TMD5Checksum.html"},
     {"title": "PXL.Data.TMD5Checksum.ByteValues", "text": " ", "tags": "", "loc": "PXL.Data.TMD5Checksum.html#ByteValues"},
     {"title": "PXL.Data.TMD5Checksum.WordValues", "text": " ", "tags": "", "loc": "PXL.Data.TMD5Checksum.html#WordValues"},
     {"title": "PXL.Data.TMD5Checksum.Values", "text": " ", "tags": "", "loc": "PXL.Data.TMD5Checksum.html#Values"},
     {"title": "PXL.Data.TMD5Checksum.LongValues", "text": " ", "tags": "", "loc": "PXL.Data.TMD5Checksum.html#LongValues"},
     {"title": "PXL.Data.Base64Binary", "text": "    ", "tags": "", "loc": "PXL.Data.html#Base64Binary"},
     {"title": "PXL.Data.Base64String", "text": " This effectively increases the size by 4/3 (rounded up). If the source is not divisible by 3, it will be padded with zeros.    ", "tags": "", "loc": "PXL.Data.html#Base64String"},
     {"title": "PXL.Data.ChecksumCRC32", "text": " This checkum can be used in integrity tests to verify that the data has not been modified.    ", "tags": "", "loc": "PXL.Data.html#ChecksumCRC32"},
     {"title": "PXL.Data.ChecksumMD5", "text": " This checksum can be used as a signature to verify that the data has not been altered in any way.    ", "tags": "", "loc": "PXL.Data.html#ChecksumMD5"},
     {"title": "PXL.Data.CompressData", "text": " The memory for both buffers must be allocated. <i>MaxDestSize</i> can be used to specify the maximum data length that can be saved at the destination buffer to prevent overflow.    ", "tags": "", "loc": "PXL.Data.html#CompressData"},
     {"title": "PXL.Data.DecompressData", "text": " The memory for both buffers must be allocated. <i>MaxDestSize</i> can be used to specify the maximum data length that can be saved at the destination buffer to prevent overflow.    ", "tags": "", "loc": "PXL.Data.html#DecompressData"},
     {"title": "PXL.Data.DecryptData", "text": "    ", "tags": "", "loc": "PXL.Data.html#DecryptData"},
     {"title": "PXL.Data.EncryptData", "text": "    ", "tags": "", "loc": "PXL.Data.html#EncryptData"},
     {"title": "PXL.Data.PCipherBlock", "text": " ", "tags": "", "loc": "PXL.Data.html#PCipherBlock"},
     {"title": "PXL.Data.PCipherKey", "text": " ", "tags": "", "loc": "PXL.Data.html#PCipherKey"},
     {"title": "PXL.Data.PMD5Checksum", "text": " ", "tags": "", "loc": "PXL.Data.html#PMD5Checksum"},
     {"title": "PXL.Data.TBase64String", "text": " ", "tags": "", "loc": "PXL.Data.html#TBase64String"},
     {"title": "PXL.Data.TCompressionLevel", "text": "  Default Default compression ratio and performance.   BestSpeed Optimize for performance at cost of compression ratio.   BestCompression Optimize for better compression ratio at cost of performance.  ", "tags": "", "loc": "PXL.Data.html#TCompressionLevel"},
     {"title": "PXL.Devices", "text": " ", "tags": "", "loc": "PXL.Devices.html"},
     {"title": "PXL.Devices.TCustomDevice", "text": " The device must be created from the factory and is one of the first objects that needs to be initialized before working with any other components. ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html"},
     {"title": "PXL.Devices.TCustomDevice.FTechFeatures", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#FTechFeatures"},
     {"title": "PXL.Devices.TCustomDevice.FTechFeatureVersion", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#FTechFeatureVersion"},
     {"title": "PXL.Devices.TCustomDevice.FTechnology", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#FTechnology"},
     {"title": "PXL.Devices.TCustomDevice.FTechVersion", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#FTechVersion"},
     {"title": "PXL.Devices.TCustomDevice.Clear", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#Clear"},
     {"title": "PXL.Devices.TCustomDevice.GetDeviceContext", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#GetDeviceContext"},
     {"title": "PXL.Devices.TCustomDevice.Context", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#Context"},
     {"title": "PXL.Devices.TCustomDevice.ImageFormatManager", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#ImageFormatManager"},
     {"title": "PXL.Devices.TCustomDevice.OnRelease", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#OnRelease"},
     {"title": "PXL.Devices.TCustomDevice.OnRestore", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#OnRestore"},
     {"title": "PXL.Devices.TCustomDevice.Provider", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#Provider"},
     {"title": "PXL.Devices.TCustomDevice.TechFeatures", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#TechFeatures"},
     {"title": "PXL.Devices.TCustomDevice.TechFeatureVersion", "text": " The difference between this parameter and <a class=\"normal\" href=\"PXL.Devices.TCustomDevice.html#TechVersion\">TechVersion</a> is that the second parameter indicates type of technology being used (for example, DirectX 3D), while this one indicates the level of features available (for example, Direct3D 9.0c). The values here are specified in hexadecimal format. That is, a value of $213 would indicate version 2.1.3. ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#TechFeatureVersion"},
     {"title": "PXL.Devices.TCustomDevice.Technology", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#Technology"},
     {"title": "PXL.Devices.TCustomDevice.TechVersion", "text": " The values are specified in hexadecimal format. That is, a value of $100 indicates version 1.0, while a value of $247 would indicate version 2.4.7. This value is used in combination with <a class=\"normal\" href=\"PXL.Devices.TCustomDevice.html#Technology\">Technology</a>, so if <code>Technology</code> is set to <i>TDeviceTechnology.Direct3D</i> and this value is set to $A10, it means that <i>Direct3D 10.1</i> is being used. ", "tags": "", "loc": "PXL.Devices.TCustomDevice.html#TechVersion"},
     {"title": "PXL.Devices.TCustomDeviceContext", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDeviceContext.html"},
     {"title": "PXL.Devices.TCustomDeviceContext.Device", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDeviceContext.html#Device"},
     {"title": "PXL.Devices.TCustomDeviceContextWriter", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDeviceContextWriter.html"},
     {"title": "PXL.Devices.TCustomDeviceContextWriter.Context", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDeviceContextWriter.html#Context"},
     {"title": "PXL.Devices.TCustomDeviceProvider", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDeviceProvider.html"},
     {"title": "PXL.Devices.TCustomDeviceProvider.CreateDevice", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomDeviceProvider.html#CreateDevice"},
     {"title": "PXL.Devices.TCustomDeviceProvider.ImageFormatManager", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomDeviceProvider.html#ImageFormatManager"},
     {"title": "PXL.Devices.TCustomStateDevice", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html"},
     {"title": "PXL.Devices.TCustomStateDevice.FInitialized", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html#FInitialized"},
     {"title": "PXL.Devices.TCustomStateDevice.Initialize", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html#Initialize"},
     {"title": "PXL.Devices.TCustomStateDevice.InitDevice", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html#InitDevice"},
     {"title": "PXL.Devices.TCustomStateDevice.Finalize", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html#Finalize"},
     {"title": "PXL.Devices.TCustomStateDevice.DoneDevice", "text": "    ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html#DoneDevice"},
     {"title": "PXL.Devices.TCustomStateDevice.Initialized", "text": " ", "tags": "", "loc": "PXL.Devices.TCustomStateDevice.html#Initialized"},
     {"title": "PXL.Devices.DeviceTechnologyToString", "text": "    ", "tags": "", "loc": "PXL.Devices.html#DeviceTechnologyToString"},
     {"title": "PXL.Devices.DeviceVersionToString", "text": " $324) into a readable text string describing that version (e.g. &quot;3.2.4&quot;). If <i>CompactForm</i> form parameter is set to <code>True</code>, the version text is reduced for trailing zeros, so a text like &quot;3.0&quot; becomes just &quot;3&quot;.    ", "tags": "", "loc": "PXL.Devices.html#DeviceVersionToString"},
     {"title": "PXL.Devices.GetFullDeviceTechString", "text": " This information can be used for informative purposes.    ", "tags": "", "loc": "PXL.Devices.html#GetFullDeviceTechString"},
     {"title": "PXL.Devices.TClearType", "text": "  Color Color buffer.   Depth Depth buffer.   Stencil Stencil buffer.  ", "tags": "", "loc": "PXL.Devices.html#TClearType"},
     {"title": "PXL.Devices.TClearTypes", "text": " ", "tags": "", "loc": "PXL.Devices.html#TClearTypes"},
     {"title": "PXL.Devices.TDeviceTechnology", "text": "  Unknown The technology has not yet been established.   Direct3D Microsoft Direct3D technology.   OpenGL OpenGL by Khronos Group.   OpenGL_ES OpenGL ES by Khronos Group.   Software Software rasterizer.   Proprietary Private proprietary technology.  ", "tags": "", "loc": "PXL.Devices.html#TDeviceTechnology"},
     {"title": "PXL.Devices.TTechnologyFeature", "text": "  Hardware Hardware-accelerated rendering.   Software Software-rasterized rendering.  ", "tags": "", "loc": "PXL.Devices.html#TTechnologyFeature"},
     {"title": "PXL.Devices.TTechnologyFeatures", "text": " ", "tags": "", "loc": "PXL.Devices.html#TTechnologyFeatures"},
     {"title": "PXL.Fonts", "text": " ", "tags": "", "loc": "PXL.Fonts.html"},
     {"title": "PXL.Fonts.TBitmapFont", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html"},
     {"title": "PXL.Fonts.TBitmapFont.DefaultBinaryExtension", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DefaultBinaryExtension"},
     {"title": "PXL.Fonts.TBitmapFont.DefaultImageExtension", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DefaultImageExtension"},
     {"title": "PXL.Fonts.TBitmapFont.DefaultXMLExtension", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DefaultXMLExtension"},
     {"title": "PXL.Fonts.TBitmapFont.FEntries", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#FEntries"},
     {"title": "PXL.Fonts.TBitmapFont.FImage", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#FImage"},
     {"title": "PXL.Fonts.TBitmapFont.FSize", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#FSize"},
     {"title": "PXL.Fonts.TBitmapFont.Create", "text": " <code>ASubscribedTextures</code> indicates whether the textures contained in font image should be subscribed to handle &quot;lost device&quot; events. If this font is part of <a class=\"normal\" href=\"PXL.Fonts.TBitmapFonts.html\">TBitmapFonts</a> list, which provides its own notification events regarding device status, then <code>ASubscribedTextures</code> should be set to <code>False</code>.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Create"},
     {"title": "PXL.Fonts.TBitmapFont.DrawTextCustom", "text": "         Position Starting position of text at top/left. Text The actual text to be drawn. Color Two colors representing vertical gradient to fill the letters with. Alpha A separate alpha representing transparency of the font (in addition to alpha provided in <code>Color</code>). TextEntryEvent Event to be called for each letter being rendered (this excludes whitespace characters such as space or #0). UserContext User context parameter that will be passed to each <code>TextEntryEvent</code> call. RestartStyling Whether the initial style of the text should be reset. This is typically needed when rendering multi-line text such as in case of <a class=\"normal\" href=\"PXL.Fonts.TBitmapFont.html#DrawTextBox\">DrawTextBox</a>.  ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DrawTextCustom"},
     {"title": "PXL.Fonts.TBitmapFont.LoadFromBinaryAsset", "text": " This includes both letter information and font image. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadFromBinaryAsset"},
     {"title": "PXL.Fonts.TBitmapFont.LoadFromBinaryFile", "text": " This includes both letter information and font image. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadFromBinaryFile"},
     {"title": "PXL.Fonts.TBitmapFont.LoadFromBinaryStream", "text": " This includes both letter information and font image. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadFromBinaryStream"},
     {"title": "PXL.Fonts.TBitmapFont.LoadFromXMLAsset", "text": " This methods accepts that one of file names is left empty and will be guessed by either changing extension from &quot;.xml&quot; to &quot;.png&quot; or vice-versa. This uses image format manager reference from associated device. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadFromXMLAsset"},
     {"title": "PXL.Fonts.TBitmapFont.LoadFromXMLFile", "text": " This methods accepts that one of file names is left empty and will be guessed by either changing extension from &quot;.xml&quot; to &quot;.png&quot; or vice-versa. This uses image format manager reference from associated device. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadFromXMLFile"},
     {"title": "PXL.Fonts.TBitmapFont.LoadFromXMLStream", "text": " This uses image format manager reference from associated device. The image extension indicates what image format for letters image is used. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadFromXMLStream"},
     {"title": "PXL.Fonts.TBitmapFont.LoadSystemFont", "text": " These are embedded within the final application and can be used at any time. The drawback of this is that these fonts don't look pretty as the pre-rendered ones and typically contain only ASCII characters. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns <code>True</code> when successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadSystemFont"},
     {"title": "PXL.Fonts.TBitmapFont.TextExtent", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextExtent"},
     {"title": "PXL.Fonts.TBitmapFont.TextExtentInt", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextExtentInt"},
     {"title": "PXL.Fonts.TBitmapFont.TextHeight", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextHeight"},
     {"title": "PXL.Fonts.TBitmapFont.TextHeightInt", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextHeightInt"},
     {"title": "PXL.Fonts.TBitmapFont.TextWidth", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextWidth"},
     {"title": "PXL.Fonts.TBitmapFont.TextWidthInt", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextWidthInt"},
     {"title": "PXL.Fonts.TBitmapFont.LoadEntriesFromXMLAsset", "text": " Returns <code>True</code> when succeeded and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadEntriesFromXMLAsset"},
     {"title": "PXL.Fonts.TBitmapFont.LoadEntriesFromXMLFile", "text": " Returns <code>True</code> when succeeded and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadEntriesFromXMLFile"},
     {"title": "PXL.Fonts.TBitmapFont.LoadEntriesFromXMLStream", "text": " Returns <code>True</code> when succeeded and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#LoadEntriesFromXMLStream"},
     {"title": "PXL.Fonts.TBitmapFont.DrawText", "text": "      Position Starting position of text at top/left. Text The actual text to be drawn. Color Two colors representing vertical gradient to fill the letters with. Alpha A separate alpha representing transparency of the font (in addition to alpha provided in <code>Color</code>).  ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DrawText"},
     {"title": "PXL.Fonts.TBitmapFont.DrawTextAligned", "text": "         Position Starting position of text at top/left. Text The actual text to be drawn. Color Two colors representing vertical gradient to fill the letters with. HorizAlign Horizontal text alignment in relation to starting position. VertAlign Vertical text alignment in relation to starting position. Alpha A separate alpha representing transparency of the font (in addition to alpha provided in <code>Color</code>). AlignToPixels Whether to align the resulting text position to start at integer location so that all letters are properly aligned to pixels. This may result in clearer text but can appear choppy during text animations (e.g. zoom in or out).  ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DrawTextAligned"},
     {"title": "PXL.Fonts.TBitmapFont.DrawTextBox", "text": "        TopLeft Top/left origin of designated area. BoxSize Width and height of the designated area in relation to top/left origin. ParagraphShift Offset to apply when new text paragraph begins. Text Multi-line text to be drawn. Color Two colors representing vertical gradient to fill the letters with. Alpha A separate alpha representing transparency of the font (in addition to alpha provided in <code>Color</code>).  ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DrawTextBox"},
     {"title": "PXL.Fonts.TBitmapFont.DrawTextCentered", "text": "       Position Origin around which the text will be rendered. Text The actual text to be drawn. Color Two colors representing vertical gradient to fill the letters with. Alpha A separate alpha representing transparency of the font (in addition to alpha provided in <code>Color</code>). AlignToPixels Whether to align the resulting text position to start at integer location so that all letters are properly aligned to pixels. This may result in clearer text but can appear choppy during text animations (e.g. zoom in or out).  ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#DrawTextCentered"},
     {"title": "PXL.Fonts.TBitmapFont.TextRects", "text": " This can be useful for components such as text edit box, for highlighting and selecting different letters.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TextRects"},
     {"title": "PXL.Fonts.TBitmapFont.Canvas", "text": " This can be changed between different drawing calls to a different canvas, as long as such canvas is bound to the same device as the font. ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Canvas"},
     {"title": "PXL.Fonts.TBitmapFont.Device", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Device"},
     {"title": "PXL.Fonts.TBitmapFont.Height", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Height"},
     {"title": "PXL.Fonts.TBitmapFont.Image", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Image"},
     {"title": "PXL.Fonts.TBitmapFont.Interleave", "text": " This can be used to expand or shrink the text. ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Interleave"},
     {"title": "PXL.Fonts.TBitmapFont.Kernings", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Kernings"},
     {"title": "PXL.Fonts.TBitmapFont.Name", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Name"},
     {"title": "PXL.Fonts.TBitmapFont.ParagraphSeparators", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#ParagraphSeparators"},
     {"title": "PXL.Fonts.TBitmapFont.Scale", "text": " Changing this value will likely result in non-pixel-perfect text rendering appearing blurry. However, it can be used for text animations. ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Scale"},
     {"title": "PXL.Fonts.TBitmapFont.Size", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Size"},
     {"title": "PXL.Fonts.TBitmapFont.SpaceWidth", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#SpaceWidth"},
     {"title": "PXL.Fonts.TBitmapFont.StyleTags", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#StyleTags"},
     {"title": "PXL.Fonts.TBitmapFont.SubscribedTextures", "text": " If this is set to <code>False</code>, likely the handling is provided by parent list class such as <a class=\"normal\" href=\"PXL.Fonts.TBitmapFonts.html\">TBitmapFonts</a> by calling the appropriate image functions. ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#SubscribedTextures"},
     {"title": "PXL.Fonts.TBitmapFont.VerticalSpace", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#VerticalSpace"},
     {"title": "PXL.Fonts.TBitmapFont.Width", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#Width"},
     {"title": "PXL.Fonts.TBitmapFont.WordSeparators", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#WordSeparators"},
     {"title": "PXL.Fonts.TBitmapFont.TTextEntryEvent", "text": "        Sender Reference to class that invoked this method. FontImage Font image that should be used as a source for drawing letter. SourceRect Rectangle in font image that contains letter image. DestRect Destination rectangle, where font image should be rendered. Color Color, which should be used for rendering the letter. UserContext User context parameter passed to <a class=\"normal\" href=\"PXL.Fonts.TBitmapFont.html#DrawTextCustom\">DrawTextCustom</a>.  ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.html#TTextEntryEvent"},
     {"title": "PXL.Fonts.TBitmapFont.TKernings", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TKernings.html"},
     {"title": "PXL.Fonts.TBitmapFont.TKernings.Create", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TKernings.html#Create"},
     {"title": "PXL.Fonts.TBitmapFont.TKernings.Destroy", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TKernings.html#Destroy"},
     {"title": "PXL.Fonts.TBitmapFont.TKernings.Spec", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TKernings.html#Spec"},
     {"title": "PXL.Fonts.TBitmapFont.TKernings.Spec", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TKernings.html#Spec"},
     {"title": "PXL.Fonts.TBitmapFont.TKernings.Shift", "text": " If no entry for that combination exists, zero (no change) is returned. ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TKernings.html#Shift"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags", "text": " These tags are specified similarly to XML tags but in simplified form. For instance, tags with names &quot;red&quot; and &quot;green&quot; with their corresponding colors can be used as in the following text: <br> <code>This is a &lt;green&gt;demo &lt;red&gt;string&lt;/&gt; with custom color&lt;/&gt; tag.</code> ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.html"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.Find", "text": " If no tag with such name exists, <code>Nil</code> is returned.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.html#Find"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.Clear", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.html#Clear"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.Delete", "text": " If no such tag exists, this method does nothing.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.html#Delete"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.Insert", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.html#Insert"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.PEntry", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.html#PEntry"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.html"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.Name", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.html#Name"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.Color", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.html#Color"},
     {"title": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.Style", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFont.TStyleTags.TEntry.html#Style"},
     {"title": "PXL.Fonts.TBitmapFonts", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html"},
     {"title": "PXL.Fonts.TBitmapFonts.Create", "text": " Elements inside this list will also be bound to this device.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Create"},
     {"title": "PXL.Fonts.TBitmapFonts.AddFromBinaryAsset", "text": " The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddFromBinaryAsset"},
     {"title": "PXL.Fonts.TBitmapFonts.AddFromBinaryFile", "text": " The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddFromBinaryFile"},
     {"title": "PXL.Fonts.TBitmapFonts.AddFromBinaryStream", "text": " The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddFromBinaryStream"},
     {"title": "PXL.Fonts.TBitmapFonts.AddFromXMLAsset", "text": " This methods accepts that one of file names is left empty and will be guessed by either changing extension from &quot;.xml&quot; to &quot;.png&quot; or vice-versa. This uses image format manager reference from associated device. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddFromXMLAsset"},
     {"title": "PXL.Fonts.TBitmapFonts.AddFromXMLFile", "text": " This methods accepts that one of file names is left empty and will be guessed by either changing extension from &quot;.xml&quot; to &quot;.png&quot; or vice-versa. This uses image format manager reference from associated device. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddFromXMLFile"},
     {"title": "PXL.Fonts.TBitmapFonts.AddFromXMLStream", "text": " This uses image format manager reference from associated device. The image extension indicates what image format for letters image is used. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddFromXMLStream"},
     {"title": "PXL.Fonts.TBitmapFonts.AddSystemFont", "text": " These are embedded within the final application and can be used at any time. The drawback of this is that these fonts don't look pretty as the pre-rendered ones and typically contain only ASCII characters. The given pixel format, if specified, will be used as a hint for initializing font letters image. Returns font index in the list when successful and -1 otherwise.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#AddSystemFont"},
     {"title": "PXL.Fonts.TBitmapFonts.Include", "text": " This implies searching the list before adding the element, which may impact performance.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Include"},
     {"title": "PXL.Fonts.TBitmapFonts.IndexOf", "text": " If no font with such name exists, returns -1.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#IndexOf"},
     {"title": "PXL.Fonts.TBitmapFonts.IndexOf", "text": " If such font is not found, -1 is returned.    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#IndexOf"},
     {"title": "PXL.Fonts.TBitmapFonts.Insert", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Insert"},
     {"title": "PXL.Fonts.TBitmapFonts.Clear", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Clear"},
     {"title": "PXL.Fonts.TBitmapFonts.MarkSearchDirty", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#MarkSearchDirty"},
     {"title": "PXL.Fonts.TBitmapFonts.Remove", "text": "    ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Remove"},
     {"title": "PXL.Fonts.TBitmapFonts.Canvas", "text": " This can be changed between different drawing calls to a different canvas, as long as such canvas is bound to the same device as the fonts. Note that setting this property changes <code>Canvas</code> value for all the fonts in the list to this same value. ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Canvas"},
     {"title": "PXL.Fonts.TBitmapFonts.Count", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Count"},
     {"title": "PXL.Fonts.TBitmapFonts.Device", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Device"},
     {"title": "PXL.Fonts.TBitmapFonts.Font", "text": " If no font with such name is found, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Font"},
     {"title": "PXL.Fonts.TBitmapFonts.Items", "text": " If the index is outside of valid range, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#Items"},
     {"title": "PXL.Fonts.TBitmapFonts.StyleTags", "text": " ", "tags": "", "loc": "PXL.Fonts.TBitmapFonts.html#StyleTags"},
     {"title": "PXL.Fonts.TSystemFontImage", "text": "  Font8x8 8x8 font that was commonly used in text mode on EGA displays with 640x350 resolution.   Font9x8 9x8 font that was commonly used in text mode on VGA displays with 720x400 resolution.  ", "tags": "", "loc": "PXL.Fonts.html#TSystemFontImage"},
     {"title": "PXL.Fonts.TTextAlignment", "text": "  Start Text should be aligned to the beginning (either top or left depending on context).   Middle Text should be centered in the middle.   Final Text should be aligned to the end (either bottom or right depending on context).  ", "tags": "", "loc": "PXL.Fonts.html#TTextAlignment"},
     {"title": "PXL.Formats", "text": " ", "tags": "", "loc": "PXL.Formats.html"},
     {"title": "PXL.Formats.TPixelFormatColorBits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatColorBits.html"},
     {"title": "PXL.Formats.TPixelFormatColorBits.Count", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatColorBits.html#Count"},
     {"title": "PXL.Formats.TPixelFormatColorBits.Shift", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatColorBits.html#Shift"},
     {"title": "PXL.Formats.TPixelFormatDescription", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html"},
     {"title": "PXL.Formats.TPixelFormatDescription.FormatType", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#FormatType"},
     {"title": "PXL.Formats.TPixelFormatDescription.BitCount", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#BitCount"},
     {"title": "PXL.Formats.TPixelFormatDescription.UsedBitCount", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#UsedBitCount"},
     {"title": "PXL.Formats.TPixelFormatDescription.RedBits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#RedBits"},
     {"title": "PXL.Formats.TPixelFormatDescription.GreenBits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#GreenBits"},
     {"title": "PXL.Formats.TPixelFormatDescription.BlueBits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#BlueBits"},
     {"title": "PXL.Formats.TPixelFormatDescription.AlphaBits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#AlphaBits"},
     {"title": "PXL.Formats.TPixelFormatDescription.LuminanceBits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#LuminanceBits"},
     {"title": "PXL.Formats.TPixelFormatDescription.CalculateUsedBitCount", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatDescription.html#CalculateUsedBitCount"},
     {"title": "PXL.Formats.TPixelFormatHelper", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html"},
     {"title": "PXL.Formats.TPixelFormatHelper.CanBulkCopyTo", "text": " For instance, it is possible to copy pixels from A8R8G8B8 to X8R8G8B8 since the second one doesn't have meaningful alpha-channel.    ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html#CanBulkCopyTo"},
     {"title": "PXL.Formats.TPixelFormatHelper.CreateFromString", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html#CreateFromString"},
     {"title": "PXL.Formats.TPixelFormatHelper.HasAlphaChannel", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html#HasAlphaChannel"},
     {"title": "PXL.Formats.TPixelFormatHelper.ToString", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html#ToString"},
     {"title": "PXL.Formats.TPixelFormatHelper.Bits", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html#Bits"},
     {"title": "PXL.Formats.TPixelFormatHelper.Bytes", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatHelper.html#Bytes"},
     {"title": "PXL.Formats.TPixelFormatList", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html"},
     {"title": "PXL.Formats.TPixelFormatList.Include", "text": " This involves searching for the entry first to determine if it's not in the list. For a faster alternative, use just <a class=\"normal\" href=\"PXL.Formats.TPixelFormatList.html#Insert\">Insert</a>.    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#Include"},
     {"title": "PXL.Formats.TPixelFormatList.IndexOf", "text": " If no such entry is found, -1 is returned.    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#IndexOf"},
     {"title": "PXL.Formats.TPixelFormatList.Insert", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#Insert"},
     {"title": "PXL.Formats.TPixelFormatList.Clear", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#Clear"},
     {"title": "PXL.Formats.TPixelFormatList.InsertAll", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#InsertAll"},
     {"title": "PXL.Formats.TPixelFormatList.Remove", "text": " If the specified index is invalid, this function does nothing.    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#Remove"},
     {"title": "PXL.Formats.TPixelFormatList.SortBestMatch", "text": "    ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#SortBestMatch"},
     {"title": "PXL.Formats.TPixelFormatList.Count", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#Count"},
     {"title": "PXL.Formats.TPixelFormatList.Items", "text": " ", "tags": "", "loc": "PXL.Formats.TPixelFormatList.html#Items"},
     {"title": "PXL.Formats.FindClosestPixelFormat", "text": " The heuristics used by this function tries not to add new channels and will never return a format that has less channels than the sample; it also tries to avoid converting between different format types like integer and floating-point formats.    ", "tags": "", "loc": "PXL.Formats.html#FindClosestPixelFormat"},
     {"title": "PXL.Formats.GetMatchingPixelFormat", "text": "    ", "tags": "", "loc": "PXL.Formats.html#GetMatchingPixelFormat"},
     {"title": "PXL.Formats.GetPixelFormatDescription", "text": " Returns <code>True</code> when successful and <code>False</code> when such information is not available (e.g. for non-standard pixel formats).    ", "tags": "", "loc": "PXL.Formats.html#GetPixelFormatDescription"},
     {"title": "PXL.Formats.Pixel32ToX", "text": " If the specified format is not supported, this function does nothing.     Source Source pixel specified in 32-bit RGBA format (<code>TPixelFormat.A8R8G8B8</code>). Dest Pointer to the memory block where the resulting pixel should be written to. This memory should be previously allocated. DestFormat Pixel format that is used to describe the destination pixel.  ", "tags": "", "loc": "PXL.Formats.html#Pixel32ToX"},
     {"title": "PXL.Formats.Pixel32ToXArray", "text": " If the specified format is not supported, this function does nothing.      Source Pointer to a valid memory block that holds the source pixels. Dest Pointer to a valid memory block where destination pixels will be written to. DestFormat Pixel format that is used to describe the destination pixels. Elements The number of pixels to convert.  ", "tags": "", "loc": "PXL.Formats.html#Pixel32ToXArray"},
     {"title": "PXL.Formats.PixelXTo32", "text": " If the specified format is not supported, this function returns zero.     Source Pointer to a valid block of memory where the source pixel is located at. SourceFormat Pixel format that is used to describe the source pixel. Resulting pixel in 32-bit RGBA format (<code>TPixelFormat.A8R8G8B8</code>). ", "tags": "", "loc": "PXL.Formats.html#PixelXTo32"},
     {"title": "PXL.Formats.PixelXTo32Array", "text": " If the specified format is not supported, this function does nothing.      Source Pointer to a valid memory block that holds the source pixels. Dest Pointer to a valid memory block where destination pixels will be written to. SourceFormat Pixel format that is used to describe the source pixels. Elements The number of pixels to convert.  ", "tags": "", "loc": "PXL.Formats.html#PixelXTo32Array"},
     {"title": "PXL.Formats.PPixelFormatColorBits", "text": " ", "tags": "", "loc": "PXL.Formats.html#PPixelFormatColorBits"},
     {"title": "PXL.Formats.PPixelFormatDescription", "text": " ", "tags": "", "loc": "PXL.Formats.html#PPixelFormatDescription"},
     {"title": "PXL.Formats.TPixelFormatType", "text": "  Normal Typical integer pixel format (e.g.  RGBA).  Float Floating-point pixel format.   Luminance Luminance pixel format (e.g.  L8A8).  Indexed Indexed (palettized) pixel format.  ", "tags": "", "loc": "PXL.Formats.html#TPixelFormatType"},
     {"title": "PXL.ImageFormats", "text": " ", "tags": "", "loc": "PXL.ImageFormats.html"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler", "text": " ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.Create", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#Create"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.LoadFromStream", "text": " <i>Context</i> parameter will contain the same value as the one passed to <a class=\"normal\" href=\"PXL.ImageFormats.TCustomImageFormatHandler.html#RegisterExtension\">RegisterExtension</a> function during creation. The rest of parameters have the same meaning as in methods inside <a class=\"normal\" href=\"PXL.ImageFormats.TCustomImageFormatManager.html\">TCustomImageFormatManager</a> class.    ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#LoadFromStream"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.SaveToStream", "text": " <i>Context</i> parameter will contain the same value as the one passed to <a class=\"normal\" href=\"PXL.ImageFormats.TCustomImageFormatHandler.html#RegisterExtension\">RegisterExtension</a> function during creation. The rest of parameters have the same meaning as in methods inside <a class=\"normal\" href=\"PXL.ImageFormats.TCustomImageFormatManager.html\">TCustomImageFormatManager</a> class.    ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#SaveToStream"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.GetManager", "text": " If there is more than one manager referring to this handler, then the first one is returned.    ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#GetManager"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.RegisterExtension", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#RegisterExtension"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.RegisterExtensions", "text": " During this call, one or more <a class=\"normal\" href=\"PXL.ImageFormats.TCustomImageFormatHandler.html#RegisterExtension\">RegisterExtension</a> calls should be made to register supported extensions.    ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#RegisterExtensions"},
     {"title": "PXL.ImageFormats.TCustomImageFormatHandler.Manager", "text": " ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatHandler.html#Manager"},
     {"title": "PXL.ImageFormats.TCustomImageFormatManager", "text": " ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatManager.html"},
     {"title": "PXL.ImageFormats.TCustomImageFormatManager.LoadFromAsset", "text": " This function only works on <i>Android</i> platform.      FileName A valid file name (with extension) that represents the image. DestSurface The destination surface where image data will be saved. It does need to be a valid instance of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>, but it may or may not be empty. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. This is just a suggestion for the manager and it may or may not be followed depending on platform implementation. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatManager.html#LoadFromAsset"},
     {"title": "PXL.ImageFormats.TCustomImageFormatManager.LoadFromFile", "text": "      FileName A valid file name (with extension) that includes full path that represents the image. DestSurface The destination surface where image data will be saved. It does need to be a valid instance of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>, but it may or may not be empty. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. This is just a suggestion for the manager and it may or may not be followed depending on platform implementation. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatManager.html#LoadFromFile"},
     {"title": "PXL.ImageFormats.TCustomImageFormatManager.LoadFromStream", "text": "       Extension Extension (including dot, e.g. &quot;.png&quot;) that represents the format in which the image is stored in the stream. Stream Stream which will be used for reading the image from. The current position of the stream will be used and after the call it will be adjusted to be right at the end of image data. DestSurface The destination surface where image data will be saved. It does need to be a valid instance of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>, but it may or may not be empty. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. This is just a suggestion for the manager and it may or may not be followed depending on platform implementation. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatManager.html#LoadFromStream"},
     {"title": "PXL.ImageFormats.TCustomImageFormatManager.SaveToFile", "text": "      FileName A valid file name (with extension) that includes full path where the image is to be saved. The path to this file must exist. SourceSurface The source surface where image data will be taken from. Note that the surface pixel format may determine the format in which the image will be saved. However, since not all pixel formats may be supported, the function may fail. Typically. <i>TPixelFormat.A8R8G8B8</i> is the most widely supported format and should work under most circumstances. Quality Generic parameter that can be used as hint for saved image quality. For instance, for JPEG files, this is typically just an integer number (typecast to Pointer) representing quality between 0 and 100. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatManager.html#SaveToFile"},
     {"title": "PXL.ImageFormats.TCustomImageFormatManager.SaveToStream", "text": "       Extension Extension (including dot, e.g. &quot;.png&quot;) that represents the format in which the image should be stored in the stream. Stream Stream which will be used for writing the image to. The current position of the stream will be used and after the call it will be adjusted to be right at the end of image data. SourceSurface The source surface where image data will be taken from. Note that the surface pixel format may determine the format in which the image will be saved. However, since not all pixel formats may be supported, the function may fail. Typically. <i>TPixelFormat.A8R8G8B8</i> is the most widely supported format and should work under most circumstances. Quality Generic parameter that can be used as hint for saved image quality. For instance, for JPEG files, this is typically just an integer number (typecast to Pointer) representing quality between 0 and 100. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TCustomImageFormatManager.html#SaveToStream"},
     {"title": "PXL.ImageFormats.TImageFormatManager", "text": " If multiple handlers that support the same image format are associated, then the one that was most recently associated will be used. ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html"},
     {"title": "PXL.ImageFormats.TImageFormatManager.IndexOfHandler", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#IndexOfHandler"},
     {"title": "PXL.ImageFormats.TImageFormatManager.LoadFromAsset", "text": " This function will look through the internal registry and use one of the most recently registered handlers that supports such extension. If no handler supports such extension, the method will fail. This function only works on <i>Android</i> platform.      FileName A valid file name (with extension) that represents the image. DestSurface The destination surface where image data will be saved. It does need to be a valid instance of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>, but it may or may not be empty. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. This is just a suggestion for the manager and it may or may not be followed depending on platform implementation. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#LoadFromAsset"},
     {"title": "PXL.ImageFormats.TImageFormatManager.LoadFromFile", "text": " This function will look through the internal registry and use one of the most recently registered handlers that supports such extension. If no handler supports such extension, the method will fail.      FileName A valid file name (with extension) that includes full path that represents the image. DestSurface The destination surface where image data will be saved. It does need to be a valid instance of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>, but it may or may not be empty. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. This is just a suggestion for the manager and it may or may not be followed depending on platform implementation. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#LoadFromFile"},
     {"title": "PXL.ImageFormats.TImageFormatManager.LoadFromStream", "text": " This function will look through the internal registry and use one of the most recently registered handlers that supports such extension. If no handler supports such extension, the method will fail.       Extension Extension (including dot, e.g. &quot;.png&quot;) that represents the format in which the image is stored in the stream. Stream Stream which will be used for reading the image from. The current position of the stream will be used and after the call it will be adjusted to be right at the end of image data. DestSurface The destination surface where image data will be saved. It does need to be a valid instance of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html\">TPixelSurface</a>, but it may or may not be empty. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. This is just a suggestion for the manager and it may or may not be followed depending on platform implementation. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#LoadFromStream"},
     {"title": "PXL.ImageFormats.TImageFormatManager.RegisterExtension", "text": " If multiple handlers are registered to the same extension, then the handler that was most recently registered will be used. <i>Context</i> parameter will be saved and then passed to the appropriate methods inside <a class=\"normal\" href=\"PXL.ImageFormats.TCustomImageFormatHandler.html\">TCustomImageFormatHandler</a> class when loading and saving images.    ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#RegisterExtension"},
     {"title": "PXL.ImageFormats.TImageFormatManager.RegisterHandler", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#RegisterHandler"},
     {"title": "PXL.ImageFormats.TImageFormatManager.SaveToFile", "text": " This function will look through the internal registry and use one of the most recently registered handlers that supports such extension. If no handler supports such extension, the method will fail.      FileName A valid file name (with extension) that includes full path where the image is to be saved. The path to this file must exist. SourceSurface The source surface where image data will be taken from. Note that the surface pixel format may determine the format in which the image will be saved. However, since not all pixel formats may be supported, the function may fail. Typically. <i>TPixelFormat.A8R8G8B8</i> is the most widely supported format and should work under most circumstances. Quality Generic parameter that can be used as hint for saved image quality. For instance, for JPEG files, this is typically just an integer number (typecast to Pointer) representing quality between 0 and 100. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#SaveToFile"},
     {"title": "PXL.ImageFormats.TImageFormatManager.SaveToStream", "text": " This function will look through the internal registry and use one of the most recently registered handlers that supports such extension. If no handler supports such extension, the method will fail.       Extension Extension (including dot, e.g. &quot;.png&quot;) that represents the format in which the image should be stored in the stream. Stream Stream which will be used for writing the image to. The current position of the stream will be used and after the call it will be adjusted to be right at the end of image data. SourceSurface The source surface where image data will be taken from. Note that the surface pixel format may determine the format in which the image will be saved. However, since not all pixel formats may be supported, the function may fail. Typically. <i>TPixelFormat.A8R8G8B8</i> is the most widely supported format and should work under most circumstances. Quality Generic parameter that can be used as hint for saved image quality. For instance, for JPEG files, this is typically just an integer number (typecast to Pointer) representing quality between 0 and 100. <code>True</code> when successful or <code>False</code> otherwise. ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#SaveToStream"},
     {"title": "PXL.ImageFormats.TImageFormatManager.UnregisterExtension", "text": " If the handler is not specified, or is <code>Nil</code>, then the first handler that supports such extension will be looked for. <code>True</code> is returned when the method success and <code>False</code> otherwise. If it is necessary to unregister all handlers for specific extension, then t his method should be called multiple times until <code>False</code> is returned.    ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#UnregisterExtension"},
     {"title": "PXL.ImageFormats.TImageFormatManager.Clear", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#Clear"},
     {"title": "PXL.ImageFormats.TImageFormatManager.UnregisterHandler", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.TImageFormatManager.html#UnregisterHandler"},
     {"title": "PXL.ImageFormats.Auto", "text": " ", "tags": "", "loc": "PXL.ImageFormats.Auto.html"},
     {"title": "PXL.ImageFormats.Auto.CreateDefaultImageFormatHandler", "text": "    ", "tags": "", "loc": "PXL.ImageFormats.Auto.html#CreateDefaultImageFormatHandler"},
     {"title": "PXL.Images", "text": " ", "tags": "", "loc": "PXL.Images.html"},
     {"title": "PXL.Images.TAtlasImage", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImage.html"},
     {"title": "PXL.Images.TAtlasImage.Create", "text": " <code>ASubscribedTextures</code> indicates whether the textures contained in this image should be subscribed to handle &quot;lost device&quot; events. If this image is part of <a class=\"normal\" href=\"PXL.Images.TAtlasImages.html\">TAtlasImages</a> list, which provides its own notification events regarding device status, then <code>ASubscribedTextures</code> should be set to <code>False</code>.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#Create"},
     {"title": "PXL.Images.TAtlasImage.DeviceRestore", "text": " Note that this method should only be called when <code>ASubscribedTextures</code> has been set to <code>False</code> during creation.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#DeviceRestore"},
     {"title": "PXL.Images.TAtlasImage.IndexOfTexture", "text": " If no such texture is found, -1 is returned.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#IndexOfTexture"},
     {"title": "PXL.Images.TAtlasImage.InsertTexture", "text": " If initialization fails, then <code>Nil</code> is returned and the texture is not added to the list.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#InsertTexture"},
     {"title": "PXL.Images.TAtlasImage.InsertTexture", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#InsertTexture"},
     {"title": "PXL.Images.TAtlasImage.LoadFromAsset", "text": " This uses image format manager reference from the associated device. Returns <code>True</code> when succeeded and <code>False</code> otherwise. The method is unsupported on non-Android platforms.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#LoadFromAsset"},
     {"title": "PXL.Images.TAtlasImage.LoadFromFile", "text": " This uses image format manager reference from the associated device. Returns <code>True</code> when succeeded and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#LoadFromFile"},
     {"title": "PXL.Images.TAtlasImage.LoadFromStream", "text": " This uses image format manager reference from the associated device. Returns <code>True</code> when succeeded and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#LoadFromStream"},
     {"title": "PXL.Images.TAtlasImage.GetRegion", "text": " If the index is outside of valid range, <code>Nil</code> is returned.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#GetRegion"},
     {"title": "PXL.Images.TAtlasImage.GetTexture", "text": " If the index is outside of valid range, <code>Nil</code> is returned.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#GetTexture"},
     {"title": "PXL.Images.TAtlasImage.GetTextureCount", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#GetTextureCount"},
     {"title": "PXL.Images.TAtlasImage.ClearTextures", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#ClearTextures"},
     {"title": "PXL.Images.TAtlasImage.DeviceRelease", "text": " Note that this method should only be called when <code>ASubscribedTextures</code> has been set to <code>False</code> during creation.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#DeviceRelease"},
     {"title": "PXL.Images.TAtlasImage.RemoveTexture", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#RemoveTexture"},
     {"title": "PXL.Images.TAtlasImage.SetupRegionPatterns", "text": " This fills <a class=\"normal\" href=\"PXL.Images.TAtlasImage.html#Regions\">Regions</a> with new data.     PatternSize Defines the size of individual pattern. VisibleSize Defines the &quot;visible&quot; size inside each individual pattern. This should either match <code>PatternSize</code> or be smaller. PatternCount Determines the total number of patterns inside the image. The total number of resulting regions will be equal or smaller than this number.  ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#SetupRegionPatterns"},
     {"title": "PXL.Images.TAtlasImage.SetupRegionPatterns", "text": " This fills <a class=\"normal\" href=\"PXL.Images.TAtlasImage.html#Regions\">Regions</a> with new data.    ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#SetupRegionPatterns"},
     {"title": "PXL.Images.TAtlasImage.Device", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#Device"},
     {"title": "PXL.Images.TAtlasImage.DynamicImage", "text": " If this parameter is set to <code>True</code>, dynamic textures will be used, where pixel data can be updated frequently. This should be used when image pixels need to be updated at least once per frame. ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#DynamicImage"},
     {"title": "PXL.Images.TAtlasImage.MipMapping", "text": " This can increase memory consumption and slow down the loading of images, but produces better visual results when the image is shrunk to smaller sizes. ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#MipMapping"},
     {"title": "PXL.Images.TAtlasImage.Name", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#Name"},
     {"title": "PXL.Images.TAtlasImage.PixelFormat", "text": " This parameter is merely a hint and different format may be used in the textures, depending on hardware support; if this format is not supported, usually the closest format will be chosen in textures. When loading pixel data, the conversion will be done automatically, if the texture format does not match the stored pixel format. ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#PixelFormat"},
     {"title": "PXL.Images.TAtlasImage.PremultipliedAlpha", "text": " This does not affect the actual pixels, it is merely a hint for rendering canvas. ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#PremultipliedAlpha"},
     {"title": "PXL.Images.TAtlasImage.Regions", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#Regions"},
     {"title": "PXL.Images.TAtlasImage.SubscribedTextures", "text": " If this is set to <code>False</code>, likely the handling is provided by parent list class such as <a class=\"normal\" href=\"PXL.Images.TAtlasImages.html\">TAtlasImages</a> through use of <a class=\"normal\" href=\"PXL.Images.TAtlasImage.html#DeviceRestore\">DeviceRestore</a> and <a class=\"normal\" href=\"PXL.Images.TAtlasImage.html#DeviceRelease\">DeviceRelease</a> events. ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#SubscribedTextures"},
     {"title": "PXL.Images.TAtlasImage.Texture", "text": " If the index is specified outside of valid range, then <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#Texture"},
     {"title": "PXL.Images.TAtlasImage.TextureCount", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImage.html#TextureCount"},
     {"title": "PXL.Images.TAtlasImages", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImages.html"},
     {"title": "PXL.Images.TAtlasImages.Create", "text": " Elements inside this list should be bound to the same device (and if they are created by this class, they automatically are).    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Create"},
     {"title": "PXL.Images.TAtlasImages.AddFromAsset", "text": " This function only works on <i>Android</i> platform. This uses image format manager reference from the associated device.       FileName A valid file name (with extension) that represents the image. ImageName New name of the image that should be added to the list. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. PixelFormat The preference for certain pixel format when loading the image. It may or may not be followed, depending on platform and support and a closest match may potentially be selected. Image index in the list or -1 on error. ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#AddFromAsset"},
     {"title": "PXL.Images.TAtlasImages.AddFromFile", "text": " This uses image format manager reference from the associated device.       FileName A valid file name (with extension) that includes full path that represents the image. ImageName New name of the image that should be added to the list. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. PixelFormat The preference for certain pixel format when loading the image. It may or may not be followed, depending on platform and support and a closest match may potentially be selected. Image index in the list or -1 on error. ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#AddFromFile"},
     {"title": "PXL.Images.TAtlasImages.AddFromStream", "text": " This uses image format manager reference from the associated device.        Extension Extension (including dot, e.g. &quot;.png&quot;) that represents the format in which the image is stored in the stream. Stream Stream which will be used for reading the image from. The current position of the stream will be used and after the call it will be adjusted to be right at the end of image data. ImageName New name of the image that should be added to the list. AlphaFormatRequest The preference for premultipled or non-premultiplied alpha that should be used while loading the image. PixelFormat The preference for certain pixel format when loading the image. It may or may not be followed, depending on platform and support and a closest match may potentially be selected. Image index in the list or -1 on error. ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#AddFromStream"},
     {"title": "PXL.Images.TAtlasImages.Include", "text": " This implies searching the list before adding the element, which may impact performance.    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Include"},
     {"title": "PXL.Images.TAtlasImages.IndexOf", "text": " If no image is found, -1 is returned.    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#IndexOf"},
     {"title": "PXL.Images.TAtlasImages.IndexOf", "text": " If no image is found, -1 is returned.    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#IndexOf"},
     {"title": "PXL.Images.TAtlasImages.Insert", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Insert"},
     {"title": "PXL.Images.TAtlasImages.Clear", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Clear"},
     {"title": "PXL.Images.TAtlasImages.MarkSearchDirty", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#MarkSearchDirty"},
     {"title": "PXL.Images.TAtlasImages.Remove", "text": "    ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Remove"},
     {"title": "PXL.Images.TAtlasImages.Device", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Device"},
     {"title": "PXL.Images.TAtlasImages.Image", "text": " If no image with such name is found, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Image"},
     {"title": "PXL.Images.TAtlasImages.ItemCount", "text": " ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#ItemCount"},
     {"title": "PXL.Images.TAtlasImages.Items", "text": " If the index is outside of valid range, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Images.TAtlasImages.html#Items"},
     {"title": "PXL.NetComs", "text": " ", "tags": "", "loc": "PXL.NetComs.html"},
     {"title": "PXL.NetComs.TNetCom", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html"},
     {"title": "PXL.NetComs.TNetCom.Initialize", "text": " <a class=\"normal\" href=\"PXL.NetComs.TNetCom.html#LocalPort\">LocalPort</a> should be set before calling this function to set a specific listening port. If <a class=\"normal\" href=\"PXL.NetComs.TNetCom.html#LocalPort\">LocalPort</a> remains zero before this call, the listening port will be selected by the system from among available ones and <a class=\"normal\" href=\"PXL.NetComs.TNetCom.html#LocalPort\">LocalPort</a> will be updated to reflect this. <code>True</code> is returned when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#Initialize"},
     {"title": "PXL.NetComs.TNetCom.ResolveHost", "text": "    ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#ResolveHost"},
     {"title": "PXL.NetComs.TNetCom.ResolveIP", "text": "    ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#ResolveIP"},
     {"title": "PXL.NetComs.TNetCom.Send", "text": "       Host Destination host or address where the message should be sent. Multicast and broadcast addresses are accepted, although should be used with care to not saturate the local network. Port Destination port where the receiver is currently listening at. Data Pointer to the message data block. The method copies the data to its internal structures, so it's not necessary to maintain the buffer after this call exits. Size Size of the message data block. <code>True</code> when the packet was sent successfully and <code>False</code> when there were errors. It is important to note that since messages are sent through UDP protocol, <code>True</code> return value doesn't necessarily mean that the packet was actually received. ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#Send"},
     {"title": "PXL.NetComs.TNetCom.Finalize", "text": "    ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#Finalize"},
     {"title": "PXL.NetComs.TNetCom.ResetStatistics", "text": "    ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#ResetStatistics"},
     {"title": "PXL.NetComs.TNetCom.Update", "text": " This method should be called as fast as possible and no less than once per second. During the call to this method, <a class=\"normal\" href=\"PXL.NetComs.TNetCom.html#OnReceive\">OnReceive</a> event may occur to notify the reception of messages.    ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#Update"},
     {"title": "PXL.NetComs.TNetCom.Broadcast", "text": " This can be written to only before the component is initialized, but can be read from at any time. ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#Broadcast"},
     {"title": "PXL.NetComs.TNetCom.BytesPerSec", "text": " In order for this variable to have meaningful values, it is necessary to call <a class=\"normal\" href=\"PXL.NetComs.TNetCom.html#Update\">Update</a> method at least once per second. ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#BytesPerSec"},
     {"title": "PXL.NetComs.TNetCom.BytesReceived", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#BytesReceived"},
     {"title": "PXL.NetComs.TNetCom.BytesSent", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#BytesSent"},
     {"title": "PXL.NetComs.TNetCom.Initialized", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#Initialized"},
     {"title": "PXL.NetComs.TNetCom.LocalIP", "text": " If several IP addresses are present, the last address in the list is returned. ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#LocalIP"},
     {"title": "PXL.NetComs.TNetCom.LocalPort", "text": " This can be written to only before the component is initialized, but can be read from at any time. ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#LocalPort"},
     {"title": "PXL.NetComs.TNetCom.OnReceive", "text": " It should always be assigned to interpret any incoming messages. ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#OnReceive"},
     {"title": "PXL.NetComs.TNetCom.ReceivedPackets", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#ReceivedPackets"},
     {"title": "PXL.NetComs.TNetCom.SentPackets", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#SentPackets"},
     {"title": "PXL.NetComs.TNetCom.UpdateRefreshTime", "text": " ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#UpdateRefreshTime"},
     {"title": "PXL.NetComs.TNetCom.TReceiveEvent", "text": " In this event the incoming message should be interpreted and properly handled. After this event executes, memory referenced by provided pointers is lost; therefore, to preserve the message it is necessary to copy it somewhere within this event. Source host and port can be used to identify the receiver and for sending replies.       Sender Reference to the class that received the message, usually <a class=\"normal\" href=\"PXL.NetComs.TNetCom.html\">TNetCom</a>. Host Source host that sent the message. Port Source port through which the message was sent. Data Pointer to the beginning of message block. Size Size of the message block.  ", "tags": "", "loc": "PXL.NetComs.TNetCom.html#TReceiveEvent"},
     {"title": "PXL.Providers", "text": " ", "tags": "", "loc": "PXL.Providers.html"},
     {"title": "PXL.Providers.TGraphicsDeviceProvider", "text": " ", "tags": "", "loc": "PXL.Providers.TGraphicsDeviceProvider.html"},
     {"title": "PXL.Providers.TGraphicsDeviceProvider.CreateCanvas", "text": "    ", "tags": "", "loc": "PXL.Providers.TGraphicsDeviceProvider.html#CreateCanvas"},
     {"title": "PXL.Providers.TGraphicsDeviceProvider.CreateDrawableTexture", "text": " If drawable textures are not supported in this provider, <code>Nil</code> is returned.    ", "tags": "", "loc": "PXL.Providers.TGraphicsDeviceProvider.html#CreateDrawableTexture"},
     {"title": "PXL.Providers.TGraphicsDeviceProvider.CreateLockableTexture", "text": "    ", "tags": "", "loc": "PXL.Providers.TGraphicsDeviceProvider.html#CreateLockableTexture"},
     {"title": "PXL.Providers.Auto", "text": " ", "tags": "", "loc": "PXL.Providers.Auto.html"},
     {"title": "PXL.Providers.Auto.CreateDefaultProvider", "text": "    ", "tags": "", "loc": "PXL.Providers.Auto.html#CreateDefaultProvider"},
     {"title": "PXL.Surfaces", "text": " ", "tags": "", "loc": "PXL.Surfaces.html"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface", "text": " ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.GetPixel", "text": " This also includes a sanity check for pixel coordinates to be within valid range. If coordinates are outside of valid range, zero should be returned.    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#GetPixel"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.GetPixelUnsafe", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#GetPixelUnsafe"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.DrawPixel", "text": " It also does a sanity check for specified coordinates and if they are outside of valid range, does nothing.    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#DrawPixel"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.DrawPixel", "text": " It also does a sanity check for specified position and if it is outside of valid range, does nothing.    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#DrawPixel"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.DrawPixelUnsafe", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#DrawPixelUnsafe"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.DrawPixelUnsafe", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#DrawPixelUnsafe"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.SetPixel", "text": " This also includes a sanity check for pixel coordinates to be within valid range. If coordinates are outside of valid range, nothing should be done.    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#SetPixel"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.SetPixelUnsafe", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#SetPixelUnsafe"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.Pixels", "text": " See <a class=\"normal\" href=\"PXL.Surfaces.TConceptualPixelSurface.html#GetPixel\">GetPixel</a> and <a class=\"normal\" href=\"PXL.Surfaces.TConceptualPixelSurface.html#SetPixel\">SetPixel</a> on how this actually works. ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#Pixels"},
     {"title": "PXL.Surfaces.TConceptualPixelSurface.PixelsUnsafe", "text": " See <a class=\"normal\" href=\"PXL.Surfaces.TConceptualPixelSurface.html#GetPixelUnsafe\">GetPixelUnsafe</a> and <a class=\"normal\" href=\"PXL.Surfaces.TConceptualPixelSurface.html#SetPixelUnsafe\">SetPixelUnsafe</a> on how this actually works. ", "tags": "", "loc": "PXL.Surfaces.TConceptualPixelSurface.html#PixelsUnsafe"},
     {"title": "PXL.Surfaces.TPixelMipMapSurface", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelMipMapSurface.html"},
     {"title": "PXL.Surfaces.TPixelMipMapSurface.CreatePixelSurfaces", "text": " This method can be overriden by more extended and/or hardware-assisted surfaces to provide extended versions of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurfaces.html\">TPixelSurfaces</a> implementation.    ", "tags": "", "loc": "PXL.Surfaces.TPixelMipMapSurface.html#CreatePixelSurfaces"},
     {"title": "PXL.Surfaces.TPixelMipMapSurface.ClearMipMaps", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelMipMapSurface.html#ClearMipMaps"},
     {"title": "PXL.Surfaces.TPixelMipMapSurface.GenerateMipMaps", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelMipMapSurface.html#GenerateMipMaps"},
     {"title": "PXL.Surfaces.TPixelMipMapSurface.MipMaps", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelMipMapSurface.html#MipMaps"},
     {"title": "PXL.Surfaces.TPixelSurface", "text": " This can serve as a base for more advanced hardware-based surfaces, but it also provides full software implementation for all the functions. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html"},
     {"title": "PXL.Surfaces.TPixelSurface.FBits", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FBits"},
     {"title": "PXL.Surfaces.TPixelSurface.FBufferSize", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FBufferSize"},
     {"title": "PXL.Surfaces.TPixelSurface.FBytesPerPixel", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FBytesPerPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.FHeight", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FHeight"},
     {"title": "PXL.Surfaces.TPixelSurface.FPitch", "text": " This may differ than the actual calculated number and may include unused or even protected memory locations, which should simply be skipped. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FPitch"},
     {"title": "PXL.Surfaces.TPixelSurface.FPixelFormat", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FPixelFormat"},
     {"title": "PXL.Surfaces.TPixelSurface.FWidth", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FWidth"},
     {"title": "PXL.Surfaces.TPixelSurface.Create", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Create"},
     {"title": "PXL.Surfaces.TPixelSurface.CreateNamed", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#CreateNamed"},
     {"title": "PXL.Surfaces.TPixelSurface.ApproximatePixelFormat", "text": " If there is no possible match, this function returns <i>TPixelFormat.Unknown</i>.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#ApproximatePixelFormat"},
     {"title": "PXL.Surfaces.TPixelSurface.ComposeWhiteBlackToGrayAlpha", "text": " This is useful in situations when an application does not generate alpha-channel, but can pre-render the image on different backgrounds - by rendering this image on black and white backgrounds, the actual alpha-channel can then be calculated using this function.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#ComposeWhiteBlackToGrayAlpha"},
     {"title": "PXL.Surfaces.TPixelSurface.ConvertPixelFormat", "text": " If both format match, the function does nothing. <code>True</code> is returned when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#ConvertPixelFormat"},
     {"title": "PXL.Surfaces.TPixelSurface.CopyFrom", "text": " If the current surface has size and/or pixel format not specified, these will be copied from the source surface as well. If current surface is not empty, then its pixel format will not be modified - in this case, pixel format conversion may occur. This function will try to ensure that current surface size matches the source surface and if if this cannot be achieved, will fail; as an alternative, <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#CopyRect\">CopyRect</a> can be used to instead copy a portion of source surface to this one. <code>True</code> is returned when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#CopyFrom"},
     {"title": "PXL.Surfaces.TPixelSurface.CopyRect", "text": " If source rectangle is empty, then the entire source surface will be copied. This function does the appropriate clipping and pixel format conversion. It does not change current surface size or pixel format. <code>True</code> is returned when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#CopyRect"},
     {"title": "PXL.Surfaces.TPixelSurface.GetBilinearPixel", "text": " This works similarly to other <i>GetBilinearPixel</i> variant that receives floating-point coordinates, but this one considers <i>FracX</i> and <i>FracY</i> as values ranging from 0 to 255, representing fractions of <i>X</i> and <i>Y</i>.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#GetBilinearPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.GetBilinearPixel", "text": " This can be used for limitless stretching, to get color values that lie between individual pixels and slowly change from one pixel to another.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#GetBilinearPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.GetPixelWithCheck", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#GetPixelWithCheck"},
     {"title": "PXL.Surfaces.TPixelSurface.HasAlphaChannel", "text": " A surface that has all its pixels with alpha-channel set to fully translucent or fully opaque (but not mixed) is considered lacking alpha-channel. On the other hand, a surface that has at least one pixel with alpha-channel value different than any other pixel, is considered to have alpha-channel. This is useful to determine whether the surface can be stored in one of pixel formats lacking alpha-channel, to avoid losing any transparency information.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#HasAlphaChannel"},
     {"title": "PXL.Surfaces.TPixelSurface.IsEmpty", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#IsEmpty"},
     {"title": "PXL.Surfaces.TPixelSurface.SetSize", "text": " This function provide sanity check on specified parameters and calls <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#Reallocate\">Reallocate</a> accordingly. <code>True</code> is returned when the operation has been successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#SetSize"},
     {"title": "PXL.Surfaces.TPixelSurface.SetSize", "text": " This function provide sanity check on specified parameters and calls <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#Reallocate\">Reallocate</a> accordingly. <code>True</code> is returned when the operation has been successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#SetSize"},
     {"title": "PXL.Surfaces.TPixelSurface.ShrinkToHalfFrom", "text": " This is specifically useful to generate mipmaps.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#ShrinkToHalfFrom"},
     {"title": "PXL.Surfaces.TPixelSurface.GetPixel", "text": " This function does range checking for <i>X</i> and <i>Y</i> parameters and if they are outside of valid range, returns completely black/translucent color (in other words, zero).    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#GetPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.GetPixelUnsafe", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#GetPixelUnsafe"},
     {"title": "PXL.Surfaces.TPixelSurface.Reallocate", "text": " This function returns <code>True</code> when the operation was successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Reallocate"},
     {"title": "PXL.Surfaces.TPixelSurface.Clear", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Clear"},
     {"title": "PXL.Surfaces.TPixelSurface.Clear", "text": " This does pixel format conversion when appropriate, so for better performance, consider using <i>Clear</i> without parameters.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Clear"},
     {"title": "PXL.Surfaces.TPixelSurface.DrawFilledRect", "text": " For filling areas with the same color without alpha-blending, a better performance can be achieved with <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#FillRect\">FillRect</a>.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#DrawFilledRect"},
     {"title": "PXL.Surfaces.TPixelSurface.DrawPixel", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#DrawPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.DrawSurface", "text": " This does pixel pixel conversion and clipping as necessary.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#DrawSurface"},
     {"title": "PXL.Surfaces.TPixelSurface.FillRect", "text": " This also does clipping when appropriate. Note that unlike <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#DrawFilledRect\">DrawFilledRect</a> method, this just sets pixels to given color, without alpha-blending.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FillRect"},
     {"title": "PXL.Surfaces.TPixelSurface.FillRect", "text": " This also does clipping when appropriate. Note that unlike <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#DrawFilledRect\">DrawFilledRect</a> method, this just sets pixels to given color, without alpha-blending.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FillRect"},
     {"title": "PXL.Surfaces.TPixelSurface.Flip", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Flip"},
     {"title": "PXL.Surfaces.TPixelSurface.FrameRect", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FrameRect"},
     {"title": "PXL.Surfaces.TPixelSurface.FrameRect", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#FrameRect"},
     {"title": "PXL.Surfaces.TPixelSurface.HorizLine", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#HorizLine"},
     {"title": "PXL.Surfaces.TPixelSurface.Mirror", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Mirror"},
     {"title": "PXL.Surfaces.TPixelSurface.PremultiplyAlpha", "text": " Note that this is an irreversible process, during which some color information is lost permanently (smaller alpha values contribute to bigger information loss). This is generally useful to prepare the image for generating mipmaps and/or alpha-blending, to get more accurate visual results.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#PremultiplyAlpha"},
     {"title": "PXL.Surfaces.TPixelSurface.ResetAlpha", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#ResetAlpha"},
     {"title": "PXL.Surfaces.TPixelSurface.StretchBilinearFrom", "text": " That is, it copies source surface rectangle onto destination rectangle with linear filtering (uses <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#GetBilinearPixel\">GetBilinearPixel</a> function). Clipping and pixel format conversion is done as necessary. Note that this function is meant for stretching only; shrinking although will also work, but result in inaccurate results as shrinking requires calculating average of variable number of pixels depending on shrink ratio.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#StretchBilinearFrom"},
     {"title": "PXL.Surfaces.TPixelSurface.StretchFrom", "text": " That is, it copies source surface rectangle onto destination rectangle with point filtering. Clipping and pixel format conversion is done as necessary. For a more accurate stretching, consider using <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#StretchBilinearFrom\">StretchBilinearFrom</a>.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#StretchFrom"},
     {"title": "PXL.Surfaces.TPixelSurface.UnpremultiplyAlpha", "text": " This can be considered an opposite or reversal process of <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#PremultiplyAlpha\">PremultiplyAlpha</a>. During this process, some color information may be lost due to precision issues. This can be useful to obtain original pixel information from image that has been previously premultiplied; however, this does not recover lost information during premultiplication process. For instance, pixels that had alpha value of zero and were premultiplied lose all information and cannot be recovered; pixels with alpha value of 128 (that is, 50% opaque) lose half of their precision and after &quot;unpremultiply&quot; process will have values multiple of 2.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#UnpremultiplyAlpha"},
     {"title": "PXL.Surfaces.TPixelSurface.VertLine", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#VertLine"},
     {"title": "PXL.Surfaces.TPixelSurface.ResetAllocation", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#ResetAllocation"},
     {"title": "PXL.Surfaces.TPixelSurface.SetPixel", "text": " This function does range checking for <i>X</i> and <i>Y</i> parameters and if they are outside of valid range, does nothing.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#SetPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.SetPixelUnsafe", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#SetPixelUnsafe"},
     {"title": "PXL.Surfaces.TPixelSurface.Bits", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Bits"},
     {"title": "PXL.Surfaces.TPixelSurface.BufferSize", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#BufferSize"},
     {"title": "PXL.Surfaces.TPixelSurface.BytesPerPixel", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#BytesPerPixel"},
     {"title": "PXL.Surfaces.TPixelSurface.Height", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Height"},
     {"title": "PXL.Surfaces.TPixelSurface.Name", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Name"},
     {"title": "PXL.Surfaces.TPixelSurface.Pitch", "text": " This may differ than the actual calculated number and may include unusued or even protected memory locations, which should simply be skipped. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Pitch"},
     {"title": "PXL.Surfaces.TPixelSurface.PixelFormat", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#PixelFormat"},
     {"title": "PXL.Surfaces.TPixelSurface.PixelPtr", "text": " If the specified coordinates are outside of valid range, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#PixelPtr"},
     {"title": "PXL.Surfaces.TPixelSurface.PremultipliedAlpha", "text": " This is just an informative parameter; to actually convert pixels from one mode to another, use <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#PremultiplyAlpha\">PremultiplyAlpha</a> and <a class=\"normal\" href=\"PXL.Surfaces.TPixelSurface.html#UnpremultiplyAlpha\">UnpremultiplyAlpha</a> methods. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#PremultipliedAlpha"},
     {"title": "PXL.Surfaces.TPixelSurface.Scanline", "text": " If the specified index is outside of valid range, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Scanline"},
     {"title": "PXL.Surfaces.TPixelSurface.Size", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Size"},
     {"title": "PXL.Surfaces.TPixelSurface.Width", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurface.html#Width"},
     {"title": "PXL.Surfaces.TPixelSurfaces", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Add", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Add"},
     {"title": "PXL.Surfaces.TPixelSurfaces.IndexOf", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#IndexOf"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Insert", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Insert"},
     {"title": "PXL.Surfaces.TPixelSurfaces.CreatePixelSurface", "text": " This resembles <i>factory pattern</i> and provides a way to instantiate extended <i>TPixelSurface</i> classes, for example, in hardware-assisted implementations.    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#CreatePixelSurface"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Clear", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Clear"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Remove", "text": "    ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Remove"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Count", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Count"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Items", "text": " ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Items"},
     {"title": "PXL.Surfaces.TPixelSurfaces.Surface", "text": " If no surface with such name exists, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.Surfaces.TPixelSurfaces.html#Surface"},
     {"title": "PXL.SwapChains", "text": " ", "tags": "", "loc": "PXL.SwapChains.html"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice", "text": " ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.BeginScene", "text": " The rendering should end with call to <a class=\"normal\" href=\"PXL.SwapChains.TCustomSwapChainDevice.html#EndScene\">EndScene</a>. Note that multiple cascade calls to <code>BeginScene</code> and <code>EndScene</code> are not allowed, so a next call to <code>BeginScene</code> without corresponding <code>EndScene</code> will fail. This function returns <code>True</code> if the rendering started successfully and <code>False</code> otherwise. If returned value is <code>False</code>, there is no need to call <a class=\"normal\" href=\"PXL.SwapChains.TCustomSwapChainDevice.html#EndScene\">EndScene</a>.    ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#BeginScene"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.EndScene", "text": " If the swap chain is located on a window, then this will present the contents.    ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#EndScene"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.Resize", "text": " The first swap chain has index of zero. If the index is outside of valid range or the swap chain cannot be resized, the returned value is <code>False</code> and the size of swap chain remains unchanged. If this method succeeds, the swap chain will have its size updated and <code>True</code> will be returned. In some providers this may cause device to be reset and some resources to be recreated, so any resources that are not handled internally should be released before calling this; the best way to handle this scenario is to subscribe in <code>TCustomDevice.OnRelease</code> and <code>TCustomDevice.OnRestore</code> events.    ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#Resize"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.MayRender", "text": "    ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#MayRender"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.ResizeSwapChain", "text": "    ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#ResizeSwapChain"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.Reset", "text": " This method works only on some modern providers.    ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#Reset"},
     {"title": "PXL.SwapChains.TCustomSwapChainDevice.SwapChains", "text": " In a typical scenario at least one swap chain must be added to this list for device initialization to succeed. In FireMonkey applications the swap chains are not used and will be ignored by the device. ", "tags": "", "loc": "PXL.SwapChains.TCustomSwapChainDevice.html#SwapChains"},
     {"title": "PXL.SwapChains.TSwapChainInfo", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html"},
     {"title": "PXL.SwapChains.TSwapChainInfo.Width", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#Width"},
     {"title": "PXL.SwapChains.TSwapChainInfo.Height", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#Height"},
     {"title": "PXL.SwapChains.TSwapChainInfo.VSync", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#VSync"},
     {"title": "PXL.SwapChains.TSwapChainInfo.Format", "text": " This is a suggestion and different format may be chosen by the provider depending on hardware support. If this parameter is set to <code>TPixelFormat.Unknown</code> (by default), the best possible pixel format will be used. ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#Format"},
     {"title": "PXL.SwapChains.TSwapChainInfo.WindowHandle", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#WindowHandle"},
     {"title": "PXL.SwapChains.TSwapChainInfo.Multisamples", "text": " This is a suggestion and different value may actually be used by the provider depending on hardware support; values of zero and one are treated as no multisampling. ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#Multisamples"},
     {"title": "PXL.SwapChains.TSwapChainInfo.DepthStencil", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChainInfo.html#DepthStencil"},
     {"title": "PXL.SwapChains.TSwapChains", "text": " This class describes all swap chains that should be created and used with the device; if the device is already initialized, modifying swap chains is not allowed. ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html"},
     {"title": "PXL.SwapChains.TSwapChains.Add", "text": "    ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Add"},
     {"title": "PXL.SwapChains.TSwapChains.Add", "text": "    ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Add"},
     {"title": "PXL.SwapChains.TSwapChains.Insert", "text": "    ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Insert"},
     {"title": "PXL.SwapChains.TSwapChains.Clear", "text": "    ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Clear"},
     {"title": "PXL.SwapChains.TSwapChains.Remove", "text": " The index should be in range of [0..(Count - 1)] range; if it is outside of valid range, this function does nothing.    ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Remove"},
     {"title": "PXL.SwapChains.TSwapChains.Count", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Count"},
     {"title": "PXL.SwapChains.TSwapChains.Device", "text": " ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Device"},
     {"title": "PXL.SwapChains.TSwapChains.Items", "text": " If the index is outside of valid range, <code>Nil</code> is returned. ", "tags": "", "loc": "PXL.SwapChains.TSwapChains.html#Items"},
     {"title": "PXL.SwapChains.PSwapChainInfo", "text": " ", "tags": "", "loc": "PXL.SwapChains.html#PSwapChainInfo"},
     {"title": "PXL.Textures", "text": " ", "tags": "", "loc": "PXL.Textures.html"},
     {"title": "PXL.Textures.TCustomBaseTexture", "text": " Each texture is typically bound to one specific device, which contains any hardware-specific context information. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html"},
     {"title": "PXL.Textures.TCustomBaseTexture.FHeight", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#FHeight"},
     {"title": "PXL.Textures.TCustomBaseTexture.FMipMapping", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#FMipMapping"},
     {"title": "PXL.Textures.TCustomBaseTexture.FPixelFormat", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#FPixelFormat"},
     {"title": "PXL.Textures.TCustomBaseTexture.FPremultipliedAlpha", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#FPremultipliedAlpha"},
     {"title": "PXL.Textures.TCustomBaseTexture.FState", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#FState"},
     {"title": "PXL.Textures.TCustomBaseTexture.FWidth", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#FWidth"},
     {"title": "PXL.Textures.TCustomBaseTexture.Create", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Create"},
     {"title": "PXL.Textures.TCustomBaseTexture.Bind", "text": " The actual meaning and functionality of this method varies on different types of hardware and platforms.    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Bind"},
     {"title": "PXL.Textures.TCustomBaseTexture.Clear", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Clear"},
     {"title": "PXL.Textures.TCustomBaseTexture.CopyFrom", "text": " If the sizes of both textures do not match, then intersection of both will be copied. This function handles the clipping and possibly pixel format conversion. <code>True</code> is returned when the operation succeeds and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#CopyFrom"},
     {"title": "PXL.Textures.TCustomBaseTexture.CopyRect", "text": " This function handles the clipping and possibly pixel format conversion. <code>True</code> is returned when the operation succeeds and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#CopyRect"},
     {"title": "PXL.Textures.TCustomBaseTexture.DeviceRestore", "text": " This should be implemented by derived classes to handle &quot;device lost&quot; scenario.    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#DeviceRestore"},
     {"title": "PXL.Textures.TCustomBaseTexture.Initialize", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Initialize"},
     {"title": "PXL.Textures.TCustomBaseTexture.DoCopyRect", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#DoCopyRect"},
     {"title": "PXL.Textures.TCustomBaseTexture.DoInitialize", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#DoInitialize"},
     {"title": "PXL.Textures.TCustomBaseTexture.DeviceRelease", "text": " This should be implemented by derived classes to handle &quot;device lost&quot; scenario.    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#DeviceRelease"},
     {"title": "PXL.Textures.TCustomBaseTexture.Finalize", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Finalize"},
     {"title": "PXL.Textures.TCustomBaseTexture.DoFinalize", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#DoFinalize"},
     {"title": "PXL.Textures.TCustomBaseTexture.Device", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Device"},
     {"title": "PXL.Textures.TCustomBaseTexture.Height", "text": " This can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Height"},
     {"title": "PXL.Textures.TCustomBaseTexture.MipMapping", "text": " Mipmapping can improve visual quality when the texture is drawn in different sizes, especially in smaller ones. This can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#MipMapping"},
     {"title": "PXL.Textures.TCustomBaseTexture.PixelFormat", "text": " This can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#PixelFormat"},
     {"title": "PXL.Textures.TCustomBaseTexture.PremultipliedAlpha", "text": " Premultiplied alpha implies permanent loss of information as the components are multiplied by alpha value and stored (so, for example, pixels with alpha value of zero permanently lose all color information), however this can improve visual quality on mipmaps with translucent pixels. This parameter is merely a hint for rendering system, it does not change the actual pixels - this is something that should be done as a separate step. This parameter can only be changed before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#PremultipliedAlpha"},
     {"title": "PXL.Textures.TCustomBaseTexture.Size", "text": " This can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Size"},
     {"title": "PXL.Textures.TCustomBaseTexture.State", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#State"},
     {"title": "PXL.Textures.TCustomBaseTexture.Width", "text": " This can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomBaseTexture.html#Width"},
     {"title": "PXL.Textures.TCustomDrawableTexture", "text": " Typically, this means that the texture is a <i>render target</i> or <i>render buffer</i>. ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html"},
     {"title": "PXL.Textures.TCustomDrawableTexture.FDepthStencil", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html#FDepthStencil"},
     {"title": "PXL.Textures.TCustomDrawableTexture.FMultisamples", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html#FMultisamples"},
     {"title": "PXL.Textures.TCustomDrawableTexture.BeginDraw", "text": " This should be implemented by derived classes to implement the appropriate functionality depending on provider and platform.    ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html#BeginDraw"},
     {"title": "PXL.Textures.TCustomDrawableTexture.EndDraw", "text": " This should be implemented by derived classes to implement the appropriate functionality depending on provider and platform.    ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html#EndDraw"},
     {"title": "PXL.Textures.TCustomDrawableTexture.DepthStencil", "text": " This can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html#DepthStencil"},
     {"title": "PXL.Textures.TCustomDrawableTexture.Multisamples", "text": " This is merely a hint and the actual number of multisamples that is being used can be overwritten when the texture is initialized. This property can be written to only before the texture is initialized, but can be read at any time. ", "tags": "", "loc": "PXL.Textures.TCustomDrawableTexture.html#Multisamples"},
     {"title": "PXL.Textures.TCustomLockableTexture", "text": " These textures are typical to most GPUs and also provide efficient means of storing dynamically changing data that is provided by CPU. ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html"},
     {"title": "PXL.Textures.TCustomLockableTexture.FBytesPerPixel", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#FBytesPerPixel"},
     {"title": "PXL.Textures.TCustomLockableTexture.FDynamicTexture", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#FDynamicTexture"},
     {"title": "PXL.Textures.TCustomLockableTexture.Clear", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#Clear"},
     {"title": "PXL.Textures.TCustomLockableTexture.CopyFromSurface", "text": " This method does clipping when applicable and calls <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Lock\">Lock</a> / <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> method pair appropriately during the process.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#CopyFromSurface"},
     {"title": "PXL.Textures.TCustomLockableTexture.CopyFromSurfaceRect", "text": " This method does clipping when applicable and calls <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Lock\">Lock</a> / <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> method pair appropriately during the process.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#CopyFromSurfaceRect"},
     {"title": "PXL.Textures.TCustomLockableTexture.CopyToSurface", "text": " This method does clipping when applicable and calls <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Lock\">Lock</a> / <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> method pair appropriately during the process.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#CopyToSurface"},
     {"title": "PXL.Textures.TCustomLockableTexture.CopyToSurfaceRect", "text": " This method does clipping when applicable and calls <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Lock\">Lock</a> / <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> method pair appropriately during the process.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#CopyToSurfaceRect"},
     {"title": "PXL.Textures.TCustomLockableTexture.Lock", "text": " The texture can be unlocked either by calling <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> or by freeing the surface returned by this function. Calling <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> also releases the surface returned by this call.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#Lock"},
     {"title": "PXL.Textures.TCustomLockableTexture.Lock", "text": " The texture can be unlocked either by calling <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> or by freeing the surface returned by this function. Calling <a class=\"normal\" href=\"PXL.Textures.TCustomLockableTexture.html#Unlock\">Unlock</a> also releases the surface returned by this call.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#Lock"},
     {"title": "PXL.Textures.TCustomLockableTexture.Lock", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#Lock"},
     {"title": "PXL.Textures.TCustomLockableTexture.Lock", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#Lock"},
     {"title": "PXL.Textures.TCustomLockableTexture.Unlock", "text": "    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#Unlock"},
     {"title": "PXL.Textures.TCustomLockableTexture.DoCopyRect", "text": " For typical applications this could be okay, but it is generally inefficient and should be re-implemented by derived classes to provide copy mechanism directly on the GPU.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#DoCopyRect"},
     {"title": "PXL.Textures.TCustomLockableTexture.DoLock", "text": " This should be implemented by derived classes. Returns <code>True</code> when the operation is successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#DoLock"},
     {"title": "PXL.Textures.TCustomLockableTexture.DoUnlock", "text": " This should be implemented by derived classes. Returns <code>True</code> when the operation is successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#DoUnlock"},
     {"title": "PXL.Textures.TCustomLockableTexture.IsLockRectFull", "text": " On some occasions, this can be useful to determine whether to pass rectangle pointer to locking mechanism or just pass <code>Nil</code> to cover the entire area.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#IsLockRectFull"},
     {"title": "PXL.Textures.TCustomLockableTexture.LockSurface", "text": " That is, a quick shortcut to &quot;lock&quot; non-GPU surface. Returns <code>True</code> when the operation is successful and <code>False</code> otherwise.    ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#LockSurface"},
     {"title": "PXL.Textures.TCustomLockableTexture.BytesPerPixel", "text": " ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#BytesPerPixel"},
     {"title": "PXL.Textures.TCustomLockableTexture.DynamicTexture", "text": " This can provide significant performance benefit but may or may not be supported on specific provider and platform. ", "tags": "", "loc": "PXL.Textures.TCustomLockableTexture.html#DynamicTexture"},
     {"title": "PXL.Textures.TLockedPixels", "text": " It is only valid while that region remains locked. ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html"},
     {"title": "PXL.Textures.TLockedPixels.Bits", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#Bits"},
     {"title": "PXL.Textures.TLockedPixels.Pitch", "text": " This may differ than the actual calculated number and may include unused or even protected memory locations, which should simply be skipped. ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#Pitch"},
     {"title": "PXL.Textures.TLockedPixels.BytesPerPixel", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#BytesPerPixel"},
     {"title": "PXL.Textures.TLockedPixels.PixelFormat", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#PixelFormat"},
     {"title": "PXL.Textures.TLockedPixels.LockedRect", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#LockedRect"},
     {"title": "PXL.Textures.TLockedPixels.Reset", "text": "    ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#Reset"},
     {"title": "PXL.Textures.TLockedPixels.PixelPtr", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#PixelPtr"},
     {"title": "PXL.Textures.TLockedPixels.Pixels", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#Pixels"},
     {"title": "PXL.Textures.TLockedPixels.Scanline", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#Scanline"},
     {"title": "PXL.Textures.TLockedPixels.Valid", "text": " ", "tags": "", "loc": "PXL.Textures.TLockedPixels.html#Valid"},
     {"title": "PXL.Textures.InvalidLockedPixels", "text": " ", "tags": "", "loc": "PXL.Textures.html#InvalidLockedPixels"},
     {"title": "PXL.Textures.PLockedPixels", "text": " ", "tags": "", "loc": "PXL.Textures.html#PLockedPixels"},
     {"title": "PXL.Textures.TTextureState", "text": "  NotInitialized The texture has not been initialized yet.   Initialized The texture has been initialized and is working fine.   Lost The surface of the texture has been lost and cannot be used right now.  It is possible that the application has been minimized and/or paused (depending on platform).  NotRecovered The surface of the texture has been lost and could not be recovered.  If the texture is found in this state, it should be released and, if needed, re-created. ", "tags": "", "loc": "PXL.Textures.html#TTextureState"},
     {"title": "PXL.Timing", "text": " ", "tags": "", "loc": "PXL.Timing.html"},
     {"title": "PXL.Timing.TMultimediaTimer", "text": " This class provides <i>OnProcess</i> event, which occurs exactly <i>Speed</i> times per second, and <i>Latency</i> property, which can be used from within <i>OnTimer</i> event as a scaling coefficient for moving things. In order to function properly, <i>NotifyTick</i> method should be called as fast as possible (for example, before rendering each frame), whereas <i>Process</i> event should be called right before flipping rendering buffers, to take advantage of parallel processing between CPU and GPU. <i>FrameRate</i> will indicate how many frames per second <i>NotifyTick</i> is called. See accompanying examples on how this component can be used. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html"},
     {"title": "PXL.Timing.TMultimediaTimer.NotifyTick", "text": " It can be either called when idle event occurs or from within system timer event.    ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#NotifyTick"},
     {"title": "PXL.Timing.TMultimediaTimer.Process", "text": " Each time this method is called, OnProcess event may (or may not) occur depending on the current rendering frame rate (see FrameRate) and the desired processing speed (see Speed). The only thing that is assured is that OnProcess event will occur exactly Speed times per second no matter how fast OnTimer occurs (that is, the value of FrameRate).    ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#Process"},
     {"title": "PXL.Timing.TMultimediaTimer.Reset", "text": " This can be useful when a very time-consuming task was executed inside OnTimer event that only occurs once. Normally, it would stall the timer making it think that the processing takes too long or the rendering is too slow; calling this method will tell the timer that it should ignore the situation and prevent the stall.    ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#Reset"},
     {"title": "PXL.Timing.TMultimediaTimer.Delta", "text": " Object movement and animation control can be made inside OnTimer event if all displacements are multiplied by this coefficient. For instance, if frame rate is 30 FPS and speed is set to 60, this coefficient will equal to 2.0, so objects moving at 30 FPS will have double displacement to match 60 FPS speed; on the other hand, if frame rate is 120 FPS with speed set to 60, this coefficient will equal to 0.5, to move objects two times slower. An easier and more straight-forward approach can be used with OnProcess event, where using this coefficient is not necessary. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#Delta"},
     {"title": "PXL.Timing.TMultimediaTimer.Enabled", "text": " The internal processing may still be occurring independently of this value, but it controls whether OnTimer event occurs or not. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#Enabled"},
     {"title": "PXL.Timing.TMultimediaTimer.FrameRate", "text": " This value is calculated approximately two times per second and can only be used for informative purposes (e.g. displaying frame rate in the application). For precise real-time indications it is recommended to use Latency property instead. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#FrameRate"},
     {"title": "PXL.Timing.TMultimediaTimer.Latency", "text": " This can be a direct indicator of rendering performance as it indicates how much time it took to render (and possibly process) the frame. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#Latency"},
     {"title": "PXL.Timing.TMultimediaTimer.MaxFPS", "text": " This value is an approximate and the resulting frame rate may be quite different (the resolution can be as low as 10 ms). It should be used with reasonable values to prevent the application from using 100% of CPU and GPU with unnecessarily high frame rates such as 1000 FPS. A reasonable and default value for this property is 200. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#MaxFPS"},
     {"title": "PXL.Timing.TMultimediaTimer.OnProcess", "text": " In this event all constant object movement and animation control should be made. This event can occur more than once for each call to Process or may not occur, depending on the current FrameRate and Speed. For instance, when frame rate is 120 FPS and speed set to 60, this event will occur for each second call to Process; on the other hand, if frame rate is 30 FPS with speed set to 60, this event will occur twice for each call to Process to maintain constant processing. An alternative to this is doing processing inside OnTimer event using Delta as coefficient for object movement. If the processing takes too much time inside this event so that the target speed cannot be achieved, the timer may stall (that is, reduce number of occurrences of this event until the balance is restored). ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#OnProcess"},
     {"title": "PXL.Timing.TMultimediaTimer.OnTimer", "text": " In this event, all rendering should be made. Inside this event, at some location it is recommended to call Process method, which will invoke OnProcess event for constant object movement and animation control. The idea is to render graphics as fast as possible while moving objects and controlling animation at constant speed. Note that for this event to occur, it is necessary to call NotifyIdle at some point in the application for this timer to do the required calculations. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#OnTimer"},
     {"title": "PXL.Timing.TMultimediaTimer.SingleCallOnly", "text": " Therefore, faster rendering produces constant speed, while slower rendering slows the processing down. This is particularly useful for dedicated servers that do no rendering but only processing; in this case, the processing cannot be technically any faster than it already is. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#SingleCallOnly"},
     {"title": "PXL.Timing.TMultimediaTimer.Speed", "text": " This affects both Delta property and occurrence of OnProcess event. ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#Speed"},
     {"title": "PXL.Timing.TMultimediaTimer.TTimerEvent", "text": "    ", "tags": "", "loc": "PXL.Timing.TMultimediaTimer.html#TTimerEvent"},
     {"title": "PXL.Timing.GetSystemTickCount", "text": " The resulting value is specified in milliseconds. The value should only be used for calculating differences because it can wrap (from very high positive value back to zero) after prolonged time intervals. The wrapping usually occurs upon reaching High(Cardinal) but depending on each individual platform, it can also occur earlier.    ", "tags": "", "loc": "PXL.Timing.html#GetSystemTickCount"},
     {"title": "PXL.Timing.GetSystemTimerValue", "text": " The resulting value is specified in microseconds. The value should only be used for calculating differences because it can wrap (from very high positive value back to zero) after prolonged time intervals. The wrapping usually occurs upon reaching High(UInt64) but depending on each individual platform, it can also occur earlier.    ", "tags": "", "loc": "PXL.Timing.html#GetSystemTimerValue"},
     {"title": "PXL.Timing.GetSystemTimeValue", "text": " The resulting value is specified in milliseconds and fractions of thereof. The value should only be used for calculating differences because it can wrap (from very high positive value back to zero or even some negative value) after prolonged time intervals.    ", "tags": "", "loc": "PXL.Timing.html#GetSystemTimeValue"},
     {"title": "PXL.Timing.MicroSleep", "text": " The sleep can actually be interrupted under certain conditions (such as when a message is sent to the caller's thread).    ", "tags": "", "loc": "PXL.Timing.html#MicroSleep"},
     {"title": "PXL.Timing.TickCountInBetween", "text": " This method takes into account potential value wrapping.    ", "tags": "", "loc": "PXL.Timing.html#TickCountInBetween"},
     {"title": "PXL.Timing.TimerValueInBetween", "text": " This method takes into account potential value wrapping.    ", "tags": "", "loc": "PXL.Timing.html#TimerValueInBetween"},
     {"title": "PXL.Timing.TSystemTimerValue", "text": " ", "tags": "", "loc": "PXL.Timing.html#TSystemTimerValue"},
     {"title": "PXL.TypeDef", "text": " ", "tags": "", "loc": "PXL.TypeDef.html"},
     {"title": "PXL.TypeDef.VectorEpsilon", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#VectorEpsilon"},
     {"title": "PXL.TypeDef.Decrement_PXL_ClassInstances", "text": " On small single-board devices such as Intel Galileo or Raspberry PI, this method is not thread-safe.    ", "tags": "", "loc": "PXL.TypeDef.html#Decrement_PXL_ClassInstances"},
     {"title": "PXL.TypeDef.FreeMemAndNil", "text": "    ", "tags": "", "loc": "PXL.TypeDef.html#FreeMemAndNil"},
     {"title": "PXL.TypeDef.Increment_PXL_ClassInstances", "text": " On small single-board devices such as Intel Galileo or Raspberry PI, this method is not thread-safe.    ", "tags": "", "loc": "PXL.TypeDef.html#Increment_PXL_ClassInstances"},
     {"title": "PXL.TypeDef.PopFPUState", "text": " If there are no items on the stack, this function does nothing.    ", "tags": "", "loc": "PXL.TypeDef.html#PopFPUState"},
     {"title": "PXL.TypeDef.PushClearFPUState", "text": " Afterwards, this function disables all FPU exceptions. This is typically used with Direct3D rendering methods that require FPU exceptions to be disabled.    ", "tags": "", "loc": "PXL.TypeDef.html#PushClearFPUState"},
     {"title": "PXL.TypeDef.PushFPUState", "text": " The stack has length of 16. If the stack becomes full, this function does nothing.    ", "tags": "", "loc": "PXL.TypeDef.html#PushFPUState"},
     {"title": "PXL.TypeDef.PSizeFloat", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PSizeFloat"},
     {"title": "PXL.TypeDef.PSizeInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PSizeInt"},
     {"title": "PXL.TypeDef.PSizeUInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PSizeUInt"},
     {"title": "PXL.TypeDef.PStdChar", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PStdChar"},
     {"title": "PXL.TypeDef.PStdString", "text": " It is not recommended to use pointer to strings, so this is mostly for internal use only. ", "tags": "", "loc": "PXL.TypeDef.html#PStdString"},
     {"title": "PXL.TypeDef.PtrInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PtrInt"},
     {"title": "PXL.TypeDef.PtrUInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PtrUInt"},
     {"title": "PXL.TypeDef.PUniChar", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PUniChar"},
     {"title": "PXL.TypeDef.PUniString", "text": " It is not recommended to use pointer to strings, so this is mostly for internal use only. ", "tags": "", "loc": "PXL.TypeDef.html#PUniString"},
     {"title": "PXL.TypeDef.PUntypedHandle", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PUntypedHandle"},
     {"title": "PXL.TypeDef.PVectorFloat", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PVectorFloat"},
     {"title": "PXL.TypeDef.PVectorInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PVectorInt"},
     {"title": "PXL.TypeDef.PVectorUInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PVectorUInt"},
     {"title": "PXL.TypeDef.SizeFloat", "text": " That is, on 32-bit platforms this is equivalent of <i>Single</i>, whereas on 64-bit platforms this is equivalent of <i>Double</i>. ", "tags": "", "loc": "PXL.TypeDef.html#SizeFloat"},
     {"title": "PXL.TypeDef.SizeInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#SizeInt"},
     {"title": "PXL.TypeDef.SizeUInt", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#SizeUInt"},
     {"title": "PXL.TypeDef.StdChar", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#StdChar"},
     {"title": "PXL.TypeDef.StdString", "text": " It may also contain Unicode-encoded text, either UTF-8 or UTF-16 depending on platform and compiler. ", "tags": "", "loc": "PXL.TypeDef.html#StdString"},
     {"title": "PXL.TypeDef.TPXL_ClassInstances", "text": " Typically, this is a 32-bit signed integer. ", "tags": "", "loc": "PXL.TypeDef.html#TPXL_ClassInstances"},
     {"title": "PXL.TypeDef.TUntypedHandle", "text": " This is a signed integer with the same size as pointer on the given platform. ", "tags": "", "loc": "PXL.TypeDef.html#TUntypedHandle"},
     {"title": "PXL.TypeDef.UniChar", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#UniChar"},
     {"title": "PXL.TypeDef.UniString", "text": " Typically, each character uses UTF-16 encoding, but it may vary depending on platform. ", "tags": "", "loc": "PXL.TypeDef.html#UniString"},
     {"title": "PXL.TypeDef.VectorFloat", "text": " Typically, it is an equivalent of <i>Single</i>, unless PXL_SCIENTIFIC_MODE is enabled, in which case it becomes equivalent of <i>Double</i>. ", "tags": "", "loc": "PXL.TypeDef.html#VectorFloat"},
     {"title": "PXL.TypeDef.VectorInt", "text": " Typically, it is 32-bit and an equivalent of <i>Integer</i>, unless PXL_SCIENTIFIC_MODE_MAX is enabled, in which case it becomes 64-bit and equivalent of <i>Int64</i>. ", "tags": "", "loc": "PXL.TypeDef.html#VectorInt"},
     {"title": "PXL.TypeDef.VectorUInt", "text": " Typically, it is 32-bit and an equivalent of <i>Cardinal</i>, unless PXL_SCIENTIFIC_MODE_MAX is enabled, in which case it becomes 64-bit and equivalent of <i>UInt64</i>. ", "tags": "", "loc": "PXL.TypeDef.html#VectorUInt"},
     {"title": "PXL.TypeDef.PXL_ClassInstances", "text": " ", "tags": "", "loc": "PXL.TypeDef.html#PXL_ClassInstances"},
     {"title": "PXL.Types", "text": " ", "tags": "", "loc": "PXL.Types.html"},
     {"title": "PXL.Types.TFloatColor", "text": " Although components may have values outside of aforementioned range, such colors cannot be reliably displayed on the screen. ", "tags": "", "loc": "PXL.Types.TFloatColor.html"},
     {"title": "PXL.Types.TFloatColor.Red", "text": " ", "tags": "", "loc": "PXL.Types.TFloatColor.html#Red"},
     {"title": "PXL.Types.TFloatColor.Green", "text": " ", "tags": "", "loc": "PXL.Types.TFloatColor.html#Green"},
     {"title": "PXL.Types.TFloatColor.Blue", "text": " ", "tags": "", "loc": "PXL.Types.TFloatColor.html#Blue"},
     {"title": "PXL.Types.TFloatColor.Alpha", "text": " ", "tags": "", "loc": "PXL.Types.TFloatColor.html#Alpha"},
     {"title": "PXL.Types.TFloatColor.Values", "text": " ", "tags": "", "loc": "PXL.Types.TFloatColor.html#Values"},
     {"title": "PXL.Types.TFloatGrayAlpha", "text": " Values outside of this range are also supported, but they cannot be reliably displayed on the screen. ", "tags": "", "loc": "PXL.Types.TFloatGrayAlpha.html"},
     {"title": "PXL.Types.TFloatGrayAlpha.Gray", "text": " ", "tags": "", "loc": "PXL.Types.TFloatGrayAlpha.html#Gray"},
     {"title": "PXL.Types.TFloatGrayAlpha.Alpha", "text": " ", "tags": "", "loc": "PXL.Types.TFloatGrayAlpha.html#Alpha"},
     {"title": "PXL.Types.TFloatGrayAlpha.Values", "text": " ", "tags": "", "loc": "PXL.Types.TFloatGrayAlpha.html#Values"},
     {"title": "PXL.Types.TFloatRect", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html"},
     {"title": "PXL.Types.TFloatRect.Left", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Left"},
     {"title": "PXL.Types.TFloatRect.Top", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Top"},
     {"title": "PXL.Types.TFloatRect.Right", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Right"},
     {"title": "PXL.Types.TFloatRect.Bottom", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Bottom"},
     {"title": "PXL.Types.TFloatRect.TopLeft", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#TopLeft"},
     {"title": "PXL.Types.TFloatRect.BottomRight", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#BottomRight"},
     {"title": "PXL.Types.TFloatRect.Values", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Values"},
     {"title": "PXL.Types.TFloatRect.Bounds", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Bounds"},
     {"title": "PXL.Types.TFloatRect.ToIntRect", "text": "    ", "tags": "", "loc": "PXL.Types.TFloatRect.html#ToIntRect"},
     {"title": "PXL.Types.TFloatRect.Empty", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Empty"},
     {"title": "PXL.Types.TFloatRect.Height", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Height"},
     {"title": "PXL.Types.TFloatRect.Size", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Size"},
     {"title": "PXL.Types.TFloatRect.Width", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect.html#Width"},
     {"title": "PXL.Types.TFloatRect4", "text": " This is typically used for rendering color filled and textured quads. ", "tags": "", "loc": "PXL.Types.TFloatRect4.html"},
     {"title": "PXL.Types.TFloatRect4.TopLeft", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect4.html#TopLeft"},
     {"title": "PXL.Types.TFloatRect4.TopRight", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect4.html#TopRight"},
     {"title": "PXL.Types.TFloatRect4.BottomRight", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect4.html#BottomRight"},
     {"title": "PXL.Types.TFloatRect4.BottomLeft", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect4.html#BottomLeft"},
     {"title": "PXL.Types.TFloatRect4.Values", "text": " ", "tags": "", "loc": "PXL.Types.TFloatRect4.html#Values"},
     {"title": "PXL.Types.TIntColor2", "text": " The format for specifying colors is defined as <i>TPixelFormat.A8R8G8B8</i>. ", "tags": "", "loc": "PXL.Types.TIntColor2.html"},
     {"title": "PXL.Types.TIntColor2.First", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor2.html#First"},
     {"title": "PXL.Types.TIntColor2.Second", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor2.html#Second"},
     {"title": "PXL.Types.TIntColor2.Values", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor2.html#Values"},
     {"title": "PXL.Types.TIntColor2.HasAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.TIntColor2.html#HasAlpha"},
     {"title": "PXL.Types.TIntColor2.HasGradient", "text": "    ", "tags": "", "loc": "PXL.Types.TIntColor2.html#HasGradient"},
     {"title": "PXL.Types.TIntColor4", "text": " The format for specifying colors is defined as <i>TPixelFormat.A8R8G8B8</i>. ", "tags": "", "loc": "PXL.Types.TIntColor4.html"},
     {"title": "PXL.Types.TIntColor4.TopLeft", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor4.html#TopLeft"},
     {"title": "PXL.Types.TIntColor4.TopRight", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor4.html#TopRight"},
     {"title": "PXL.Types.TIntColor4.BottomRight", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor4.html#BottomRight"},
     {"title": "PXL.Types.TIntColor4.BottomLeft", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor4.html#BottomLeft"},
     {"title": "PXL.Types.TIntColor4.Values", "text": " ", "tags": "", "loc": "PXL.Types.TIntColor4.html#Values"},
     {"title": "PXL.Types.TIntColor4.HasAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.TIntColor4.html#HasAlpha"},
     {"title": "PXL.Types.TIntColor4.HasGradient", "text": "    ", "tags": "", "loc": "PXL.Types.TIntColor4.html#HasGradient"},
     {"title": "PXL.Types.TIntColorRec", "text": " This can be safely typecast to <a class=\"normal\" href=\"PXL.Types.html#TIntColor\">TIntColor</a> and vice-versa. ", "tags": "", "loc": "PXL.Types.TIntColorRec.html"},
     {"title": "PXL.Types.TIntColorRec.Blue", "text": " ", "tags": "", "loc": "PXL.Types.TIntColorRec.html#Blue"},
     {"title": "PXL.Types.TIntColorRec.Green", "text": " ", "tags": "", "loc": "PXL.Types.TIntColorRec.html#Green"},
     {"title": "PXL.Types.TIntColorRec.Red", "text": " ", "tags": "", "loc": "PXL.Types.TIntColorRec.html#Red"},
     {"title": "PXL.Types.TIntColorRec.Alpha", "text": " ", "tags": "", "loc": "PXL.Types.TIntColorRec.html#Alpha"},
     {"title": "PXL.Types.TIntColorRec.Values", "text": " ", "tags": "", "loc": "PXL.Types.TIntColorRec.html#Values"},
     {"title": "PXL.Types.TIntGrayAlphaRec", "text": " This can be safely typecast to <a class=\"normal\" href=\"PXL.Types.html#TIntGrayAlpha\">TIntGrayAlpha</a> and vice-versa. ", "tags": "", "loc": "PXL.Types.TIntGrayAlphaRec.html"},
     {"title": "PXL.Types.TIntGrayAlphaRec.Gray", "text": " ", "tags": "", "loc": "PXL.Types.TIntGrayAlphaRec.html#Gray"},
     {"title": "PXL.Types.TIntGrayAlphaRec.Alpha", "text": " ", "tags": "", "loc": "PXL.Types.TIntGrayAlphaRec.html#Alpha"},
     {"title": "PXL.Types.TIntGrayAlphaRec.Values", "text": " ", "tags": "", "loc": "PXL.Types.TIntGrayAlphaRec.html#Values"},
     {"title": "PXL.Types.TIntRect", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html"},
     {"title": "PXL.Types.TIntRect.Left", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Left"},
     {"title": "PXL.Types.TIntRect.Top", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Top"},
     {"title": "PXL.Types.TIntRect.Right", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Right"},
     {"title": "PXL.Types.TIntRect.Bottom", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Bottom"},
     {"title": "PXL.Types.TIntRect.TopLeft", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#TopLeft"},
     {"title": "PXL.Types.TIntRect.BottomRight", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#BottomRight"},
     {"title": "PXL.Types.TIntRect.Values", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Values"},
     {"title": "PXL.Types.TIntRect.Bounds", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Bounds"},
     {"title": "PXL.Types.TIntRect.Empty", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Empty"},
     {"title": "PXL.Types.TIntRect.Height", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Height"},
     {"title": "PXL.Types.TIntRect.Size", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Size"},
     {"title": "PXL.Types.TIntRect.Width", "text": " ", "tags": "", "loc": "PXL.Types.TIntRect.html#Width"},
     {"title": "PXL.Types.TMatrix3", "text": " ", "tags": "", "loc": "PXL.Types.TMatrix3.html"},
     {"title": "PXL.Types.TMatrix3.Data", "text": " ", "tags": "", "loc": "PXL.Types.TMatrix3.html#Data"},
     {"title": "PXL.Types.TMatrix3.Determinant", "text": "    ", "tags": "", "loc": "PXL.Types.TMatrix3.html#Determinant"},
     {"title": "PXL.Types.TMatrix4", "text": " ", "tags": "", "loc": "PXL.Types.TMatrix4.html"},
     {"title": "PXL.Types.TMatrix4.Data", "text": " ", "tags": "", "loc": "PXL.Types.TMatrix4.html#Data"},
     {"title": "PXL.Types.TMatrix4.Determinant", "text": "    ", "tags": "", "loc": "PXL.Types.TMatrix4.html#Determinant"},
     {"title": "PXL.Types.TMatrix4.EyePos", "text": "    ", "tags": "", "loc": "PXL.Types.TMatrix4.html#EyePos"},
     {"title": "PXL.Types.TMatrix4.WorldPos", "text": "    ", "tags": "", "loc": "PXL.Types.TMatrix4.html#WorldPos"},
     {"title": "PXL.Types.TPoint2", "text": " ", "tags": "", "loc": "PXL.Types.TPoint2.html"},
     {"title": "PXL.Types.TPoint2.X", "text": " ", "tags": "", "loc": "PXL.Types.TPoint2.html#X"},
     {"title": "PXL.Types.TPoint2.Y", "text": " ", "tags": "", "loc": "PXL.Types.TPoint2.html#Y"},
     {"title": "PXL.Types.TPoint2px", "text": " ", "tags": "", "loc": "PXL.Types.TPoint2px.html"},
     {"title": "PXL.Types.TPoint2px.X", "text": " ", "tags": "", "loc": "PXL.Types.TPoint2px.html#X"},
     {"title": "PXL.Types.TPoint2px.Y", "text": " ", "tags": "", "loc": "PXL.Types.TPoint2px.html#Y"},
     {"title": "PXL.Types.TQuaternion", "text": " ", "tags": "", "loc": "PXL.Types.TQuaternion.html"},
     {"title": "PXL.Types.TQuaternion.X", "text": " ", "tags": "", "loc": "PXL.Types.TQuaternion.html#X"},
     {"title": "PXL.Types.TQuaternion.Y", "text": " ", "tags": "", "loc": "PXL.Types.TQuaternion.html#Y"},
     {"title": "PXL.Types.TQuaternion.Z", "text": " ", "tags": "", "loc": "PXL.Types.TQuaternion.html#Z"},
     {"title": "PXL.Types.TQuaternion.W", "text": " ", "tags": "", "loc": "PXL.Types.TQuaternion.html#W"},
     {"title": "PXL.Types.TVector3", "text": " ", "tags": "", "loc": "PXL.Types.TVector3.html"},
     {"title": "PXL.Types.TVector3.X", "text": " ", "tags": "", "loc": "PXL.Types.TVector3.html#X"},
     {"title": "PXL.Types.TVector3.Y", "text": " ", "tags": "", "loc": "PXL.Types.TVector3.html#Y"},
     {"title": "PXL.Types.TVector3.Z", "text": " ", "tags": "", "loc": "PXL.Types.TVector3.html#Z"},
     {"title": "PXL.Types.TVector3.GetXY", "text": "    ", "tags": "", "loc": "PXL.Types.TVector3.html#GetXY"},
     {"title": "PXL.Types.TVector3.GetXYpx", "text": "    ", "tags": "", "loc": "PXL.Types.TVector3.html#GetXYpx"},
     {"title": "PXL.Types.TVector3px", "text": " ", "tags": "", "loc": "PXL.Types.TVector3px.html"},
     {"title": "PXL.Types.TVector3px.X", "text": " ", "tags": "", "loc": "PXL.Types.TVector3px.html#X"},
     {"title": "PXL.Types.TVector3px.Y", "text": " ", "tags": "", "loc": "PXL.Types.TVector3px.html#Y"},
     {"title": "PXL.Types.TVector3px.Z", "text": " ", "tags": "", "loc": "PXL.Types.TVector3px.html#Z"},
     {"title": "PXL.Types.TVector3px.GetXY", "text": "    ", "tags": "", "loc": "PXL.Types.TVector3px.html#GetXY"},
     {"title": "PXL.Types.TVector4", "text": " ", "tags": "", "loc": "PXL.Types.TVector4.html"},
     {"title": "PXL.Types.TVector4.X", "text": " ", "tags": "", "loc": "PXL.Types.TVector4.html#X"},
     {"title": "PXL.Types.TVector4.Y", "text": " ", "tags": "", "loc": "PXL.Types.TVector4.html#Y"},
     {"title": "PXL.Types.TVector4.Z", "text": " ", "tags": "", "loc": "PXL.Types.TVector4.html#Z"},
     {"title": "PXL.Types.TVector4.W", "text": " Typically, this component is set to 1.0. ", "tags": "", "loc": "PXL.Types.TVector4.html#W"},
     {"title": "PXL.Types.TVector4.GetXYZ", "text": "    ", "tags": "", "loc": "PXL.Types.TVector4.html#GetXYZ"},
     {"title": "PXL.Types.TVector4.ProjectToXYZ", "text": "    ", "tags": "", "loc": "PXL.Types.TVector4.html#ProjectToXYZ"},
     {"title": "PXL.Types.AxisWVec4", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisWVec4"},
     {"title": "PXL.Types.AxisXPoint2", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisXPoint2"},
     {"title": "PXL.Types.AxisXPoint2px", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisXPoint2px"},
     {"title": "PXL.Types.AxisXVec3", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisXVec3"},
     {"title": "PXL.Types.AxisXVec3px", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisXVec3px"},
     {"title": "PXL.Types.AxisXVec4", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisXVec4"},
     {"title": "PXL.Types.AxisXVec4H", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisXVec4H"},
     {"title": "PXL.Types.AxisYPoint2", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisYPoint2"},
     {"title": "PXL.Types.AxisYPoint2px", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisYPoint2px"},
     {"title": "PXL.Types.AxisYVec3", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisYVec3"},
     {"title": "PXL.Types.AxisYVec3px", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisYVec3px"},
     {"title": "PXL.Types.AxisYVec4", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisYVec4"},
     {"title": "PXL.Types.AxisYVec4H", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisYVec4H"},
     {"title": "PXL.Types.AxisZVec3", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisZVec3"},
     {"title": "PXL.Types.AxisZVec3px", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisZVec3px"},
     {"title": "PXL.Types.AxisZVec4", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisZVec4"},
     {"title": "PXL.Types.AxisZVec4H", "text": " ", "tags": "", "loc": "PXL.Types.html#AxisZVec4H"},
     {"title": "PXL.Types.FloatColorBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatColorBlack"},
     {"title": "PXL.Types.FloatColorTranslucentBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatColorTranslucentBlack"},
     {"title": "PXL.Types.FloatColorTranslucentWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatColorTranslucentWhite"},
     {"title": "PXL.Types.FloatColorWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatColorWhite"},
     {"title": "PXL.Types.FloatGrayAlphaBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatGrayAlphaBlack"},
     {"title": "PXL.Types.FloatGrayAlphaTranslucentBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatGrayAlphaTranslucentBlack"},
     {"title": "PXL.Types.FloatGrayAlphaTranslucentWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatGrayAlphaTranslucentWhite"},
     {"title": "PXL.Types.FloatGrayAlphaWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#FloatGrayAlphaWhite"},
     {"title": "PXL.Types.IdentityMtx3", "text": " ", "tags": "", "loc": "PXL.Types.html#IdentityMtx3"},
     {"title": "PXL.Types.IdentityMtx4", "text": " ", "tags": "", "loc": "PXL.Types.html#IdentityMtx4"},
     {"title": "PXL.Types.IdentityQuat", "text": " ", "tags": "", "loc": "PXL.Types.html#IdentityQuat"},
     {"title": "PXL.Types.IntColorBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorBlack"},
     {"title": "PXL.Types.IntColorBlack2", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorBlack2"},
     {"title": "PXL.Types.IntColorBlack4", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorBlack4"},
     {"title": "PXL.Types.IntColorTranslucentBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorTranslucentBlack"},
     {"title": "PXL.Types.IntColorTranslucentBlack2", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorTranslucentBlack2"},
     {"title": "PXL.Types.IntColorTranslucentBlack4", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorTranslucentBlack4"},
     {"title": "PXL.Types.IntColorTranslucentWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorTranslucentWhite"},
     {"title": "PXL.Types.IntColorTranslucentWhite2", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorTranslucentWhite2"},
     {"title": "PXL.Types.IntColorTranslucentWhite4", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorTranslucentWhite4"},
     {"title": "PXL.Types.IntColorWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorWhite"},
     {"title": "PXL.Types.IntColorWhite2", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorWhite2"},
     {"title": "PXL.Types.IntColorWhite4", "text": " ", "tags": "", "loc": "PXL.Types.html#IntColorWhite4"},
     {"title": "PXL.Types.IntGrayAlphaBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#IntGrayAlphaBlack"},
     {"title": "PXL.Types.IntGrayAlphaTranslucentBlack", "text": " ", "tags": "", "loc": "PXL.Types.html#IntGrayAlphaTranslucentBlack"},
     {"title": "PXL.Types.IntGrayAlphaTranslucentWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#IntGrayAlphaTranslucentWhite"},
     {"title": "PXL.Types.IntGrayAlphaWhite", "text": " ", "tags": "", "loc": "PXL.Types.html#IntGrayAlphaWhite"},
     {"title": "PXL.Types.MinusInfinity2px", "text": " ", "tags": "", "loc": "PXL.Types.html#MinusInfinity2px"},
     {"title": "PXL.Types.PlusInfinity2px", "text": " ", "tags": "", "loc": "PXL.Types.html#PlusInfinity2px"},
     {"title": "PXL.Types.Undefined2px", "text": " ", "tags": "", "loc": "PXL.Types.html#Undefined2px"},
     {"title": "PXL.Types.UnityPoint2", "text": " ", "tags": "", "loc": "PXL.Types.html#UnityPoint2"},
     {"title": "PXL.Types.UnityPoint2px", "text": " ", "tags": "", "loc": "PXL.Types.html#UnityPoint2px"},
     {"title": "PXL.Types.UnityVec3", "text": " ", "tags": "", "loc": "PXL.Types.html#UnityVec3"},
     {"title": "PXL.Types.UnityVec3px", "text": " ", "tags": "", "loc": "PXL.Types.html#UnityVec3px"},
     {"title": "PXL.Types.UnityVec4", "text": " ", "tags": "", "loc": "PXL.Types.html#UnityVec4"},
     {"title": "PXL.Types.ZeroFloatRect", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroFloatRect"},
     {"title": "PXL.Types.ZeroIntRect", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroIntRect"},
     {"title": "PXL.Types.ZeroMtx3", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroMtx3"},
     {"title": "PXL.Types.ZeroMtx4", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroMtx4"},
     {"title": "PXL.Types.ZeroPoint2", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroPoint2"},
     {"title": "PXL.Types.ZeroPoint2px", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroPoint2px"},
     {"title": "PXL.Types.ZeroVec3", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroVec3"},
     {"title": "PXL.Types.ZeroVec3px", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroVec3px"},
     {"title": "PXL.Types.ZeroVec4", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroVec4"},
     {"title": "PXL.Types.ZeroVec4H", "text": " ", "tags": "", "loc": "PXL.Types.html#ZeroVec4H"},
     {"title": "PXL.Types.AddGrayPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#AddGrayPixels"},
     {"title": "PXL.Types.AddPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#AddPixels"},
     {"title": "PXL.Types.AdjointMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#AdjointMtx3"},
     {"title": "PXL.Types.AdjointMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#AdjointMtx4"},
     {"title": "PXL.Types.Angle2", "text": "    ", "tags": "", "loc": "PXL.Types.html#Angle2"},
     {"title": "PXL.Types.Angle2px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Angle2px"},
     {"title": "PXL.Types.Angle3", "text": " The returned value has range of [0..Pi].    ", "tags": "", "loc": "PXL.Types.html#Angle3"},
     {"title": "PXL.Types.Angle3px", "text": " The returned value has range of [0..Pi].    ", "tags": "", "loc": "PXL.Types.html#Angle3px"},
     {"title": "PXL.Types.AverageColors", "text": "    ", "tags": "", "loc": "PXL.Types.html#AverageColors"},
     {"title": "PXL.Types.AverageFourPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#AverageFourPixels"},
     {"title": "PXL.Types.AverageGrayColors", "text": "    ", "tags": "", "loc": "PXL.Types.html#AverageGrayColors"},
     {"title": "PXL.Types.AverageGrayPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#AverageGrayPixels"},
     {"title": "PXL.Types.AveragePixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#AveragePixels"},
     {"title": "PXL.Types.AverageSixPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#AverageSixPixels"},
     {"title": "PXL.Types.BlendFourPixels", "text": " <i>AlphaX</i> and <i>AlphaY</i> can be in [0..255] range.    ", "tags": "", "loc": "PXL.Types.html#BlendFourPixels"},
     {"title": "PXL.Types.BlendGrayPixels", "text": " <i>Alpha</i> can be in [0..255] range.    ", "tags": "", "loc": "PXL.Types.html#BlendGrayPixels"},
     {"title": "PXL.Types.BlendPixels", "text": " <i>Alpha</i> can be in [0..255] range.    ", "tags": "", "loc": "PXL.Types.html#BlendPixels"},
     {"title": "PXL.Types.CatmullRom", "text": "    ", "tags": "", "loc": "PXL.Types.html#CatmullRom"},
     {"title": "PXL.Types.CatmullRom2", "text": "       PredPoint1 Predecessor to <i>Point1</i> that defines initial part of curve. Point1 First base point used in interpolation (for Theta = 0). Point2 Last base point used in interpolation (for Theta = 1). SuccPoint2 Successor to <i>Point2</i> that defines final part of curve.. Theta Mixture coefficient between two vector in range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#CatmullRom2"},
     {"title": "PXL.Types.CatmullRom2px", "text": "       PredPoint1 Predecessor to <i>Point1</i> that defines initial part of curve. Point1 First base point used in interpolation (for Theta = 0). Point2 Last base point used in interpolation (for Theta = 1). SuccPoint2 Successor to <i>Point2</i> that defines final part of curve.. Theta Mixture coefficient between two vector in range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#CatmullRom2px"},
     {"title": "PXL.Types.CatmullRom3", "text": "       PreVector1 Predecessor to <i>Vector1</i> that defines initial part of curve. Vector1 First base vector used in interpolation (for Theta = 0). Vector2 Second base vector used in interpolation (for Theta = 1). PostVector2 Successor to <i>Vector2</i> that defines final part of curve.. Theta Mixture coefficient between two vector in range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#CatmullRom3"},
     {"title": "PXL.Types.CatmullRom3px", "text": "       PreVector1 Predecessor to <i>Vector1</i> that defines initial part of curve. Vector1 First base vector used in interpolation (for Theta = 0). Vector2 Second base vector used in interpolation (for Theta = 1). PostVector2 Successor to <i>Vector2</i> that defines final part of curve.. Theta Mixture coefficient between two vector in range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#CatmullRom3px"},
     {"title": "PXL.Types.CatmullRom4", "text": "       PredVector1 Predecessor to <i>Vector1</i> that defines initial part of curve. Vector1 First base vector used in interpolation (for Theta = 0). Vector2 Second base vector used in interpolation (for Theta = 1). SuccVector2 Successor to <i>Vector2</i> that defines final part of curve.. Theta Mixture coefficient between two vector in range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#CatmullRom4"},
     {"title": "PXL.Types.CatmullRomColors", "text": " <i>Theta</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#CatmullRomColors"},
     {"title": "PXL.Types.CatmullRomPixels", "text": " <i>Theta</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#CatmullRomPixels"},
     {"title": "PXL.Types.CeilPowerOfTwo", "text": "    ", "tags": "", "loc": "PXL.Types.html#CeilPowerOfTwo"},
     {"title": "PXL.Types.ClipCoords", "text": " Returns <code>True</code> when the clipping was successful or <code>False</code> when there is nothing left.    ", "tags": "", "loc": "PXL.Types.html#ClipCoords"},
     {"title": "PXL.Types.ClipCoords", "text": " Returns <code>True</code> when the clipping was successful or <code>False</code> when there is nothing left.    ", "tags": "", "loc": "PXL.Types.html#ClipCoords"},
     {"title": "PXL.Types.ColorToGray", "text": " The resulting value can be considered the color's <i>luma</i>. The alpha-channel is ignored.    ", "tags": "", "loc": "PXL.Types.html#ColorToGray"},
     {"title": "PXL.Types.ColorToVec3", "text": "    ", "tags": "", "loc": "PXL.Types.html#ColorToVec3"},
     {"title": "PXL.Types.ColorToVec4", "text": "    ", "tags": "", "loc": "PXL.Types.html#ColorToVec4"},
     {"title": "PXL.Types.ConjugateQuat", "text": " The resulting quaternion has opposite rotation to the original quaternion.    ", "tags": "", "loc": "PXL.Types.html#ConjugateQuat"},
     {"title": "PXL.Types.Cross2", "text": "    ", "tags": "", "loc": "PXL.Types.html#Cross2"},
     {"title": "PXL.Types.Cross2px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Cross2px"},
     {"title": "PXL.Types.Cross3", "text": " The resulting vector is perpendicular to both source vectors and normal to the plane containing them.    ", "tags": "", "loc": "PXL.Types.html#Cross3"},
     {"title": "PXL.Types.Cross3px", "text": " The resulting vector is perpendicular to both source vectors and normal to the plane containing them.    ", "tags": "", "loc": "PXL.Types.html#Cross3px"},
     {"title": "PXL.Types.DisplaceRB", "text": "    ", "tags": "", "loc": "PXL.Types.html#DisplaceRB"},
     {"title": "PXL.Types.Dot2", "text": " The dot-product is an indirect measure of the angle between two vectors.    ", "tags": "", "loc": "PXL.Types.html#Dot2"},
     {"title": "PXL.Types.Dot2px", "text": " The dot-product is an indirect measure of the angle between two vectors.    ", "tags": "", "loc": "PXL.Types.html#Dot2px"},
     {"title": "PXL.Types.Dot3", "text": " The dot-product is an indirect measure of angle between two vectors.    ", "tags": "", "loc": "PXL.Types.html#Dot3"},
     {"title": "PXL.Types.Dot3px", "text": " The dot-product is an indirect measure of angle between two vectors.    ", "tags": "", "loc": "PXL.Types.html#Dot3px"},
     {"title": "PXL.Types.DotQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#DotQuat"},
     {"title": "PXL.Types.ExpQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#ExpQuat"},
     {"title": "PXL.Types.ExtractGrayAlpha", "text": " The sample must be rendered with the same color on two different backgrounds, preferably on black and white; the resulting colors are provided in <i>Src1</i> and <i>Src2</i>, with original backgrounds in <i>Bk1</i> and <i>Bk2</i>. The resulting alpha-channel and original color are computed and returned. This method is particularly useful for calculating alpha-channel when rendering GDI fonts or in tools that generate resulting images without providing alpha-channel (therefore rendering the same image on two backgrounds is sufficient to calculate its alpha-channel).    ", "tags": "", "loc": "PXL.Types.html#ExtractGrayAlpha"},
     {"title": "PXL.Types.ExtractGrayAlpha", "text": " The sample must be rendered with the same color on two different backgrounds, preferably on black and white; the resulting colors are provided in <i>Src1</i> and <i>Src2</i>, with original backgrounds in <i>Bk1</i> and <i>Bk2</i>. The resulting alpha-channel and original color are computed and returned. This method is particularly useful for calculating alpha-channel when rendering GDI fonts or in tools that generate resulting images without providing alpha-channel (therefore rendering the same image on two backgrounds is sufficient to calculate its alpha-channel).    ", "tags": "", "loc": "PXL.Types.html#ExtractGrayAlpha"},
     {"title": "PXL.Types.FlipRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#FlipRect4"},
     {"title": "PXL.Types.FloatColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatColor"},
     {"title": "PXL.Types.FloatColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatColor"},
     {"title": "PXL.Types.FloatColorToGray", "text": " Resulting gray component can be considered the color's <i>luma</i>.    ", "tags": "", "loc": "PXL.Types.html#FloatColorToGray"},
     {"title": "PXL.Types.FloatGrayAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatGrayAlpha"},
     {"title": "PXL.Types.FloatGrayAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatGrayAlpha"},
     {"title": "PXL.Types.FloatGrayToColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatGrayToColor"},
     {"title": "PXL.Types.FloatRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect"},
     {"title": "PXL.Types.FloatRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect"},
     {"title": "PXL.Types.FloatRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect4"},
     {"title": "PXL.Types.FloatRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect4"},
     {"title": "PXL.Types.FloatRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect4"},
     {"title": "PXL.Types.FloatRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect4"},
     {"title": "PXL.Types.FloatRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect4"},
     {"title": "PXL.Types.FloatRect4R", "text": " The rectangle is then rotated and scaled around the specified middle point (assumed to be inside rectangle's dimensions) and placed in center of the specified origin.    ", "tags": "", "loc": "PXL.Types.html#FloatRect4R"},
     {"title": "PXL.Types.FloatRect4RC", "text": " The rectangle is then rotated and scaled around its center and placed at the specified origin.    ", "tags": "", "loc": "PXL.Types.html#FloatRect4RC"},
     {"title": "PXL.Types.FloatRect4RTL", "text": " The rectangle is then rotated and scaled around the specified middle point (assumed to be inside rectangle's dimensions) and placed in the center of the specified origin. The difference between this method and <a class=\"normal\" href=\"PXL.Types.html#FloatRect4R\">FloatRect4R</a> is that the rotation does not preserve centering of the rectangle in case where middle point is not actually located in the middle.    ", "tags": "", "loc": "PXL.Types.html#FloatRect4RTL"},
     {"title": "PXL.Types.FloatRect4S", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRect4S"},
     {"title": "PXL.Types.FloatRectBDS", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRectBDS"},
     {"title": "PXL.Types.FloatRectBDS", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatRectBDS"},
     {"title": "PXL.Types.FloatToIntColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatToIntColor"},
     {"title": "PXL.Types.FloatToIntGrayAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloatToIntGrayAlpha"},
     {"title": "PXL.Types.FloorPowerOfTwo", "text": "    ", "tags": "", "loc": "PXL.Types.html#FloorPowerOfTwo"},
     {"title": "PXL.Types.HeadingPitchBankMtx4", "text": " Each of the components is specified individually.    ", "tags": "", "loc": "PXL.Types.html#HeadingPitchBankMtx4"},
     {"title": "PXL.Types.HeadingPitchBankMtx4", "text": " The components are taken from the specified vector with Y corresponding to heading, X to pitch and Z to bank.    ", "tags": "", "loc": "PXL.Types.html#HeadingPitchBankMtx4"},
     {"title": "PXL.Types.InflateRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#InflateRect"},
     {"title": "PXL.Types.InflateRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#InflateRect"},
     {"title": "PXL.Types.InflateRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#InflateRect"},
     {"title": "PXL.Types.InflateRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#InflateRect"},
     {"title": "PXL.Types.IntColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor"},
     {"title": "PXL.Types.IntColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor"},
     {"title": "PXL.Types.IntColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor"},
     {"title": "PXL.Types.IntColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor"},
     {"title": "PXL.Types.IntColor2", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor2"},
     {"title": "PXL.Types.IntColor2", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor2"},
     {"title": "PXL.Types.IntColor4", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor4"},
     {"title": "PXL.Types.IntColor4", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor4"},
     {"title": "PXL.Types.IntColor4H", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor4H"},
     {"title": "PXL.Types.IntColor4H", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor4H"},
     {"title": "PXL.Types.IntColor4V", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor4V"},
     {"title": "PXL.Types.IntColor4V", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColor4V"},
     {"title": "PXL.Types.IntColorAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColorAlpha"},
     {"title": "PXL.Types.IntColorAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColorAlpha"},
     {"title": "PXL.Types.IntColorGray", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColorGray"},
     {"title": "PXL.Types.IntColorGray", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColorGray"},
     {"title": "PXL.Types.IntColorRGB", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColorRGB"},
     {"title": "PXL.Types.IntColorToGray", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntColorToGray"},
     {"title": "PXL.Types.IntersectRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntersectRect"},
     {"title": "PXL.Types.IntersectRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntersectRect"},
     {"title": "PXL.Types.IntGrayAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntGrayAlpha"},
     {"title": "PXL.Types.IntGrayAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntGrayAlpha"},
     {"title": "PXL.Types.IntGrayToColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntGrayToColor"},
     {"title": "PXL.Types.IntRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntRect"},
     {"title": "PXL.Types.IntRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntRect"},
     {"title": "PXL.Types.IntRectBDS", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntRectBDS"},
     {"title": "PXL.Types.IntRectBDS", "text": "    ", "tags": "", "loc": "PXL.Types.html#IntRectBDS"},
     {"title": "PXL.Types.InverseMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#InverseMtx3"},
     {"title": "PXL.Types.InvertColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#InvertColor"},
     {"title": "PXL.Types.InvertGrayColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#InvertGrayColor"},
     {"title": "PXL.Types.InvertMtx4", "text": " In other words, the new matrix will &quot;undo&quot; any transformations that the given matrix would have made.    ", "tags": "", "loc": "PXL.Types.html#InvertMtx4"},
     {"title": "PXL.Types.InvertPixel", "text": "    ", "tags": "", "loc": "PXL.Types.html#InvertPixel"},
     {"title": "PXL.Types.IsPowerOfTwo", "text": "    ", "tags": "", "loc": "PXL.Types.html#IsPowerOfTwo"},
     {"title": "PXL.Types.Length2", "text": "    ", "tags": "", "loc": "PXL.Types.html#Length2"},
     {"title": "PXL.Types.Length2px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Length2px"},
     {"title": "PXL.Types.Length3", "text": "    ", "tags": "", "loc": "PXL.Types.html#Length3"},
     {"title": "PXL.Types.Length3px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Length3px"},
     {"title": "PXL.Types.Length4", "text": "    ", "tags": "", "loc": "PXL.Types.html#Length4"},
     {"title": "PXL.Types.LengthQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#LengthQuat"},
     {"title": "PXL.Types.Lerp", "text": "    ", "tags": "", "loc": "PXL.Types.html#Lerp"},
     {"title": "PXL.Types.Lerp2", "text": "     Point1 The first vector to be used in the interpolation Point2 The second vector to be used in the interpolation Theta The mixture of the two vectors with the a range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#Lerp2"},
     {"title": "PXL.Types.Lerp2px", "text": "     Point1 The first vector to be used in the interpolation Point2 The second vector to be used in the interpolation Theta The mixture of the two vectors with the a range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#Lerp2px"},
     {"title": "PXL.Types.Lerp3", "text": "     Vector1 The first vector to be used in the interpolation Vector2 The second vector to be used in the interpolation Theta The mixture of the two vectors with the a range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#Lerp3"},
     {"title": "PXL.Types.Lerp3px", "text": "     Vector1 The first vector to be used in the interpolation Vector2 The second vector to be used in the interpolation Theta The mixture of the two vectors with the a range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#Lerp3px"},
     {"title": "PXL.Types.Lerp4", "text": "     Vector1 The first vector to be used in the interpolation Vector2 The second vector to be used in the interpolation Theta The mixture of the two vectors with the a range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#Lerp4"},
     {"title": "PXL.Types.LerpColors", "text": " <i>Alpha</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#LerpColors"},
     {"title": "PXL.Types.LerpFourPixels", "text": " <i>AlphaX</i> and <i>AlphaY</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#LerpFourPixels"},
     {"title": "PXL.Types.LerpGrayColors", "text": " <i>Alpha</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#LerpGrayColors"},
     {"title": "PXL.Types.LerpGrayPixels", "text": " For a faster alternative, use <a class=\"normal\" href=\"PXL.Types.html#BlendGrayPixels\">BlendGrayPixels</a>. <i>Alpha</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#LerpGrayPixels"},
     {"title": "PXL.Types.LerpPixels", "text": " For a faster alternative, use <a class=\"normal\" href=\"PXL.Types.html#BlendPixels\">BlendPixels</a>. <i>Alpha</i> can be in [0..1] range.    ", "tags": "", "loc": "PXL.Types.html#LerpPixels"},
     {"title": "PXL.Types.LookAtMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#LookAtMtx4"},
     {"title": "PXL.Types.MirrorRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#MirrorRect4"},
     {"title": "PXL.Types.MultiplyGrayPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#MultiplyGrayPixels"},
     {"title": "PXL.Types.MultiplyPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#MultiplyPixels"},
     {"title": "PXL.Types.Norm2", "text": " If the vector is of zero length, it will remain unchanged.    ", "tags": "", "loc": "PXL.Types.html#Norm2"},
     {"title": "PXL.Types.Norm3", "text": " If the vector is of zero length, it will remain unchanged.    ", "tags": "", "loc": "PXL.Types.html#Norm3"},
     {"title": "PXL.Types.Norm4", "text": " The second parameter is used to prevent division by zero in vectors that are of zero length.    ", "tags": "", "loc": "PXL.Types.html#Norm4"},
     {"title": "PXL.Types.NormalizeQuat", "text": " Note that normally quaternions are always normalized (of course, within limits of numerical precision). This function is provided mainly to combat floating point &quot;error creep&quot;, which occurs after many successive quaternion operations.    ", "tags": "", "loc": "PXL.Types.html#NormalizeQuat"},
     {"title": "PXL.Types.OffsetRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#OffsetRect"},
     {"title": "PXL.Types.OffsetRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#OffsetRect"},
     {"title": "PXL.Types.OffsetRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#OffsetRect"},
     {"title": "PXL.Types.OffsetRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#OffsetRect"},
     {"title": "PXL.Types.OffsetRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#OffsetRect4"},
     {"title": "PXL.Types.OffsetRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#OffsetRect4"},
     {"title": "PXL.Types.OrthogonalBDSMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#OrthogonalBDSMtx4"},
     {"title": "PXL.Types.OrthogonalVOLMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#OrthogonalVOLMtx4"},
     {"title": "PXL.Types.OverlapRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#OverlapRect"},
     {"title": "PXL.Types.OverlapRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#OverlapRect"},
     {"title": "PXL.Types.Parallel3", "text": "    ", "tags": "", "loc": "PXL.Types.html#Parallel3"},
     {"title": "PXL.Types.Perp3", "text": "    ", "tags": "", "loc": "PXL.Types.html#Perp3"},
     {"title": "PXL.Types.PerspectiveBDSMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#PerspectiveBDSMtx4"},
     {"title": "PXL.Types.PerspectiveFOVXMtx4", "text": " In 3D shooters the field of view needs to be adjusted to allow more visible area on wide-screen monitors. The parameters that define the viewed range are important for defining the precision of the depth transformation or a depth-buffer.      FieldOfView The camera's field of view in radians. For example Pi/4. AspectRatio The screen's aspect ratio. Can be calculated as x/y. MinRange The closest range at which the scene will be viewed. MaxRange The farthest range at which the scene will be viewed.  ", "tags": "", "loc": "PXL.Types.html#PerspectiveFOVXMtx4"},
     {"title": "PXL.Types.PerspectiveFOVYMtx4", "text": " This is a common way for typical 3D applications. In 3D shooters special care is to be taken because on wide-screen monitors the visible area will be bigger when using this constructor. The parameters that define the viewed range are important for defining the precision of the depth transformation or a depth-buffer.      FieldOfView The camera's field of view in radians. For example Pi/4. AspectRatio The screen's aspect ratio. Can be calculated as y/x. MinRange The closest range at which the scene will be viewed. MaxRange The farthest range at which the scene will be viewed.  ", "tags": "", "loc": "PXL.Types.html#PerspectiveFOVYMtx4"},
     {"title": "PXL.Types.PerspectiveVOLMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#PerspectiveVOLMtx4"},
     {"title": "PXL.Types.PixelToGray", "text": " The resulting value can be considered the color's <i>luma</i>. The alpha-channel is ignored.    ", "tags": "", "loc": "PXL.Types.html#PixelToGray"},
     {"title": "PXL.Types.PixelToGrayFloat", "text": " The resulting value can be considered the color's <i>luma</i>. The alpha-channel is ignored.    ", "tags": "", "loc": "PXL.Types.html#PixelToGrayFloat"},
     {"title": "PXL.Types.Point2", "text": "    ", "tags": "", "loc": "PXL.Types.html#Point2"},
     {"title": "PXL.Types.Point2px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Point2px"},
     {"title": "PXL.Types.Point2ToPx", "text": "    ", "tags": "", "loc": "PXL.Types.html#Point2ToPx"},
     {"title": "PXL.Types.PointInRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#PointInRect"},
     {"title": "PXL.Types.PointInRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#PointInRect"},
     {"title": "PXL.Types.PointInRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#PointInRect4"},
     {"title": "PXL.Types.PointInTriangle", "text": "    ", "tags": "", "loc": "PXL.Types.html#PointInTriangle"},
     {"title": "PXL.Types.PointInTriangle", "text": "    ", "tags": "", "loc": "PXL.Types.html#PointInTriangle"},
     {"title": "PXL.Types.PremultiplyAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#PremultiplyAlpha"},
     {"title": "PXL.Types.PremultiplyAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#PremultiplyAlpha"},
     {"title": "PXL.Types.PremultiplyGrayColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#PremultiplyGrayColor"},
     {"title": "PXL.Types.PremultiplyGrayPixel", "text": "    ", "tags": "", "loc": "PXL.Types.html#PremultiplyGrayPixel"},
     {"title": "PXL.Types.RandomGaussValueEnd", "text": "    ", "tags": "", "loc": "PXL.Types.html#RandomGaussValueEnd"},
     {"title": "PXL.Types.RandomGaussValueMiddle", "text": "    ", "tags": "", "loc": "PXL.Types.html#RandomGaussValueMiddle"},
     {"title": "PXL.Types.RandomGaussValueOmni", "text": " Note that this function does not do limit checks, so numbers outside of [-1..1] range might rarely occur.    ", "tags": "", "loc": "PXL.Types.html#RandomGaussValueOmni"},
     {"title": "PXL.Types.RandomGaussValueStart", "text": "    ", "tags": "", "loc": "PXL.Types.html#RandomGaussValueStart"},
     {"title": "PXL.Types.RectInRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#RectInRect"},
     {"title": "PXL.Types.RectInRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#RectInRect"},
     {"title": "PXL.Types.Reflect3", "text": "    ", "tags": "", "loc": "PXL.Types.html#Reflect3"},
     {"title": "PXL.Types.ReflectMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#ReflectMtx4"},
     {"title": "PXL.Types.RotateAboutAxisQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateAboutAxisQuat"},
     {"title": "PXL.Types.RotateAboutXQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateAboutXQuat"},
     {"title": "PXL.Types.RotateAboutYQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateAboutYQuat"},
     {"title": "PXL.Types.RotateAboutZQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateAboutZQuat"},
     {"title": "PXL.Types.RotateInertialToObjectQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateInertialToObjectQuat"},
     {"title": "PXL.Types.RotateMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateMtx3"},
     {"title": "PXL.Types.RotateMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateMtx4"},
     {"title": "PXL.Types.RotateObjectToIntertialQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateObjectToIntertialQuat"},
     {"title": "PXL.Types.RotateXMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateXMtx4"},
     {"title": "PXL.Types.RotateYMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateYMtx4"},
     {"title": "PXL.Types.RotateZMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotateZMtx4"},
     {"title": "PXL.Types.RotationAngleQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotationAngleQuat"},
     {"title": "PXL.Types.RotationAxisQuat", "text": "    ", "tags": "", "loc": "PXL.Types.html#RotationAxisQuat"},
     {"title": "PXL.Types.Saturate", "text": "    ", "tags": "", "loc": "PXL.Types.html#Saturate"},
     {"title": "PXL.Types.Saturate", "text": "    ", "tags": "", "loc": "PXL.Types.html#Saturate"},
     {"title": "PXL.Types.SaturateColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#SaturateColor"},
     {"title": "PXL.Types.SaturateGrayColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#SaturateGrayColor"},
     {"title": "PXL.Types.ScaleMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleMtx3"},
     {"title": "PXL.Types.ScaleMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleMtx3"},
     {"title": "PXL.Types.ScaleMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleMtx3"},
     {"title": "PXL.Types.ScaleMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleMtx4"},
     {"title": "PXL.Types.ScaleMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleMtx4"},
     {"title": "PXL.Types.ScaleMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleMtx4"},
     {"title": "PXL.Types.ScaleRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#ScaleRect4"},
     {"title": "PXL.Types.SineAccelerate", "text": " The curve starts at 0 with almost zero acceleration, but in the end going almost linearly.    ", "tags": "", "loc": "PXL.Types.html#SineAccelerate"},
     {"title": "PXL.Types.SineCycle", "text": " Note that the curve goes from 0 to 1 and then back to 0.    ", "tags": "", "loc": "PXL.Types.html#SineCycle"},
     {"title": "PXL.Types.SineDecelerate", "text": " The curve starts accelerating quickly at 0, but slowly stops at 1.    ", "tags": "", "loc": "PXL.Types.html#SineDecelerate"},
     {"title": "PXL.Types.SineSymCycle", "text": "    ", "tags": "", "loc": "PXL.Types.html#SineSymCycle"},
     {"title": "PXL.Types.SineTransform", "text": "    ", "tags": "", "loc": "PXL.Types.html#SineTransform"},
     {"title": "PXL.Types.SlerpQuat", "text": "     Quat1 Source quaternion to be used in the interpolation Quat2 Destination quaternion to be used in the interpolation Theta The mixture of the two quaternions with range of [0..1].  ", "tags": "", "loc": "PXL.Types.html#SlerpQuat"},
     {"title": "PXL.Types.SubtractGrayPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#SubtractGrayPixels"},
     {"title": "PXL.Types.SubtractPixels", "text": "    ", "tags": "", "loc": "PXL.Types.html#SubtractPixels"},
     {"title": "PXL.Types.TransformRect4", "text": "    ", "tags": "", "loc": "PXL.Types.html#TransformRect4"},
     {"title": "PXL.Types.TranslateMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#TranslateMtx3"},
     {"title": "PXL.Types.TranslateMtx3", "text": "    ", "tags": "", "loc": "PXL.Types.html#TranslateMtx3"},
     {"title": "PXL.Types.TranslateMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#TranslateMtx4"},
     {"title": "PXL.Types.TranslateMtx4", "text": "    ", "tags": "", "loc": "PXL.Types.html#TranslateMtx4"},
     {"title": "PXL.Types.TransposeMtx3", "text": " That is, rows become columns and vice-versa.    ", "tags": "", "loc": "PXL.Types.html#TransposeMtx3"},
     {"title": "PXL.Types.TransposeMtx4", "text": " That is, rows become columns and vice-versa.    ", "tags": "", "loc": "PXL.Types.html#TransposeMtx4"},
     {"title": "PXL.Types.UnionRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#UnionRect"},
     {"title": "PXL.Types.UnionRect", "text": "    ", "tags": "", "loc": "PXL.Types.html#UnionRect"},
     {"title": "PXL.Types.UnpremultiplyAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#UnpremultiplyAlpha"},
     {"title": "PXL.Types.UnpremultiplyAlpha", "text": "    ", "tags": "", "loc": "PXL.Types.html#UnpremultiplyAlpha"},
     {"title": "PXL.Types.UnpremultiplyGrayColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#UnpremultiplyGrayColor"},
     {"title": "PXL.Types.UnpremultiplyGrayPixel", "text": "    ", "tags": "", "loc": "PXL.Types.html#UnpremultiplyGrayPixel"},
     {"title": "PXL.Types.Vec3ToColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vec3ToColor"},
     {"title": "PXL.Types.Vec4ToColor", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vec4ToColor"},
     {"title": "PXL.Types.Vector3", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector3"},
     {"title": "PXL.Types.Vector3", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector3"},
     {"title": "PXL.Types.Vector3px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector3px"},
     {"title": "PXL.Types.Vector3px", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector3px"},
     {"title": "PXL.Types.Vector3ToPx", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector3ToPx"},
     {"title": "PXL.Types.Vector4", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector4"},
     {"title": "PXL.Types.Vector4", "text": "    ", "tags": "", "loc": "PXL.Types.html#Vector4"},
     {"title": "PXL.Types.WarpColor", "text": " The process is different from <a class=\"normal\" href=\"PXL.Types.html#SaturateColor\">SaturateColor</a> approach and may produce some interesting visual effects.    ", "tags": "", "loc": "PXL.Types.html#WarpColor"},
     {"title": "PXL.Types.YawPitchRollMtx4", "text": " The components are taken from the specified vector with Y corresponding to yaw, X to pitch and Z to roll.    ", "tags": "", "loc": "PXL.Types.html#YawPitchRollMtx4"},
     {"title": "PXL.Types.YawPitchRollMtx4", "text": " Each of the components is specified individually.    ", "tags": "", "loc": "PXL.Types.html#YawPitchRollMtx4"},
     {"title": "PXL.Types.PDepthStencil", "text": " ", "tags": "", "loc": "PXL.Types.html#PDepthStencil"},
     {"title": "PXL.Types.PFloatColor", "text": " ", "tags": "", "loc": "PXL.Types.html#PFloatColor"},
     {"title": "PXL.Types.PFloatGrayAlpha", "text": " ", "tags": "", "loc": "PXL.Types.html#PFloatGrayAlpha"},
     {"title": "PXL.Types.PFloatRect", "text": " ", "tags": "", "loc": "PXL.Types.html#PFloatRect"},
     {"title": "PXL.Types.PFloatRect4", "text": " ", "tags": "", "loc": "PXL.Types.html#PFloatRect4"},
     {"title": "PXL.Types.PIntColor", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntColor"},
     {"title": "PXL.Types.PIntColor2", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntColor2"},
     {"title": "PXL.Types.PIntColor4", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntColor4"},
     {"title": "PXL.Types.PIntColorPalette", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntColorPalette"},
     {"title": "PXL.Types.PIntColorRec", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntColorRec"},
     {"title": "PXL.Types.PIntColorValue", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntColorValue"},
     {"title": "PXL.Types.PIntGrayAlpha", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntGrayAlpha"},
     {"title": "PXL.Types.PIntGrayAlphaRec", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntGrayAlphaRec"},
     {"title": "PXL.Types.PIntGrayAlphaValue", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntGrayAlphaValue"},
     {"title": "PXL.Types.PIntRect", "text": " ", "tags": "", "loc": "PXL.Types.html#PIntRect"},
     {"title": "PXL.Types.PMatrix3", "text": " ", "tags": "", "loc": "PXL.Types.html#PMatrix3"},
     {"title": "PXL.Types.PMatrix4", "text": " ", "tags": "", "loc": "PXL.Types.html#PMatrix4"},
     {"title": "PXL.Types.PPixelFormat", "text": " ", "tags": "", "loc": "PXL.Types.html#PPixelFormat"},
     {"title": "PXL.Types.PPoint2", "text": " ", "tags": "", "loc": "PXL.Types.html#PPoint2"},
     {"title": "PXL.Types.PPoint2px", "text": " ", "tags": "", "loc": "PXL.Types.html#PPoint2px"},
     {"title": "PXL.Types.PQuaternion", "text": " ", "tags": "", "loc": "PXL.Types.html#PQuaternion"},
     {"title": "PXL.Types.PVector3", "text": " ", "tags": "", "loc": "PXL.Types.html#PVector3"},
     {"title": "PXL.Types.PVector3px", "text": " ", "tags": "", "loc": "PXL.Types.html#PVector3px"},
     {"title": "PXL.Types.PVector4", "text": " ", "tags": "", "loc": "PXL.Types.html#PVector4"},
     {"title": "PXL.Types.TAlphaFormatRequest", "text": "  DontCare Alpha-channel can be handled either way.  <br> <br>  NonPremultiplied Alpha-channel in the image should not be premultiplied.  Under normal circumstances, this is the recommended approach as it preserves RGB color information in its original form. However, when using mipmapping for images that have alpha-channel, <i>Premultiplied</i> gives more accurate results. <br> <br>  Premultiplied Alpha-channel in the image should be premultiplied.  Under normal circumstances, this is not recommended as the image would lose information after RGB components are premultiplied by alpha (and for smaller alpha values, less information is preserved). However, when using mipmapping for images that have alpha-channel, this gives more accurate results. ", "tags": "", "loc": "PXL.Types.html#TAlphaFormatRequest"},
     {"title": "PXL.Types.TDepthStencil", "text": "  None No depth or stencil buffers should be supported.  <br> <br>  DepthOnly Depth but not stencil buffers should be supported.  <br> <br>  Full Both depth and stencil buffers should be supported.  ", "tags": "", "loc": "PXL.Types.html#TDepthStencil"},
     {"title": "PXL.Types.TIntColor", "text": " ", "tags": "", "loc": "PXL.Types.html#TIntColor"},
     {"title": "PXL.Types.TIntColorPalette", "text": " ", "tags": "", "loc": "PXL.Types.html#TIntColorPalette"},
     {"title": "PXL.Types.TIntColorValue", "text": " ", "tags": "", "loc": "PXL.Types.html#TIntColorValue"},
     {"title": "PXL.Types.TIntGrayAlpha", "text": " ", "tags": "", "loc": "PXL.Types.html#TIntGrayAlpha"},
     {"title": "PXL.Types.TIntGrayAlphaValue", "text": " ", "tags": "", "loc": "PXL.Types.html#TIntGrayAlphaValue"},
     {"title": "PXL.Types.TPixelFormat", "text": " The order of letters in the constants defines the order of the encoded components; R stands for Red, G for Green, B for Blue, A for Alpha, L for Luminance and X for Not Used (or discarded); F at the end means floating-point format.  Unknown Unknown pixel format.  It is usually returned when no valid pixel format is available. In some cases, it can be specified to indicate that the format should be selected by default or automatically. <br> <br>  A8R8G8B8 32-bit RGBA pixel format.  The most commonly used pixel format for storing and loading textures and images. <br> <br>  X8R8G8B8 32-bit RGB pixel format that has no alpha-channel.  Should be used for images and textures that have no transparency information in them. <br> <br>  A4R4G4B4 16-bit RGBA pixel format with 4 bits for each channel.  This format can be used as a replacement for <i>A8R8G8B8</i> format in cases where memory footprint is important at the expense of visual quality. <br> <br>  X4R4G4B4 16-bit RGB pixel format with 4 bits unused.  It is basically <i>A4R4G4B4</i> with alpha-channel discarded. This format is widely supported, but in typical applications it is more convenient to use <i>R5G6B5</i> instead. <br> <br>  R5G6B5 16-bit RGB pixel format.  This format can be used as an alternative to A8R8G8B8 in cases where memory footprint is important at the expense of visual quality. <br> <br>  A1R5G5B5 16-bit RGBA pixel format with one bit dedicated for alpha-channel.  This format can be used for images where a transparency mask is used; that is, the pixel is either transparent or not, typical for those images where a single color is picked to be transparent. In this product, there is little need for this format because <i>AlphaTool</i> can be used to generate alpha channel for images with masked color, which then can be used with any other higher-quality format. <br> <br>  X1R5G5B5 16-bit RGB pixel format with only 15 bits used for actual storage.  This format was common on legacy hardware but recently it is rarely used or even supported. <br> <br>  A2R2G2B2 8-bit RGBA pixel format that was originally supported by OpenGL in earlier implementations.  This format can significantly save disk space and memory consumption (if supported in hardware) but at the expense of very low visual quality. <br> <br>  R3G3B2 8-bit RGB pixel format.  An extreme low-quality format useful only in special circumstances and mainly for storage. It is more commonly supported on ATI video cards than on Nvidia, being really scarce on newer hardware. <br> <br>  A8R3G3B2 16-bit RGBA pixel format with uneven bit distribution among the components.  It is more supported on ATI video cards and can be rarely found on newer hardware. In many cases it is more useful to use <i>A4R4G4B4</i> format. <br> <br>  A2B10G10R10 32-bit RGBA pixel format with 10 bits used for each component of red, green and blue, being a higher-quality variant of <i>A8R8G8B8</i>.  It is more commonly supported on some video cards than its more practical cousin <i>A2R10G10B10</i>. <br> <br>  A16B16G16R16 64-bit RGBA pixel format with each channel having 16 bits.  <br> <br>  A8L8 16-bit luminance pixel format.  One of the best formats to be used with bitmap fonts, which is also widely supported. <br> <br>  A4L4 8-bit luminance pixel format.  This format can be used as a low quality replacement for <i>A8L8</i> to represent bitmap fonts. <br> <br>  L16 16-bit luminance pixel format that can be used to represent high-quality grayscale images and textures.  <br> <br>  L8 8-bit luminance pixel format.  This format can be used for grayscale images and textures. <br> <br>  R16F 16-bit floating-point pixel format, which has only one component.  This is useful in shaders either as a render target or as a data source. <br> <br>  G16R16F 32-bit floating-point pixel format containing two components with 16 bits each.  This can be used in shaders as a data source. <br> <br>  A16B16G16R16F 64-bit floating-point RGBA pixel format with each component having 16 bits.  It can be used as a special purpose texture or a render target with shaders. <br> <br>  R32F 32-bit floating-point pixel format, which has only one component.  This format is typically used as render target for shadow mapping. <br> <br>  G32R32F 64-bit floating-point pixel format containing two components with 32 bits each, mainly useful in shaders as a data source.  <br> <br>  A32B32G32R32F 128-bit floating-point RGBA pixel format with each component having 32 bits.  It can be used as a special purpose texture or a render target with shaders. <br> <br>  A8 8-bit alpha pixel format.  This format can be used as an alpha-channel format for applications that require low memory footprint and require transparency information only. Its usefulness, however, is severely limited because it is only supported only on newer video cards and when converted in hardware to <i>A8R8G8B8</i>, it has zero values for red, green and blue components; in other words, it is basically a black color that also has alpha channel. <br> <br>  G16R16 32-bit pixel format that has only green and red components 16 bits each.  This format is more useful for shaders where only one or two components are needed but with extra resolution. <br> <br>  A2R10G10B10 32-bit RGBA pixel format with 10 bits used for each component of red, green and blue, with only 2 bits dedicated to alpha channel.  <br> <br>  A8B8G8R8 32-bit BGRA pixel format.  This is similar to <i>A8R8G8B8</i> format but with red and blue components exchanged. <br> <br>  X8B8G8R8 32-bit BGR pixel format that has no alpha-channel, similar to <i>X8R8G8B8</i> but with red and blue components exchanged.  <br> <br>  R8G8B8 24-bit RGB pixel format.  This format can be used for storage and it is unsuitable for rendering both on <i>DirectX</i> and <i>OpenGL</i>. <br> <br>  B8G8R8A8 32-bit ABGR pixel format.  This format is common to some MSB configurations such as <i>Apple Carbon</i> interface. <br> <br>  B8G8R8X8 32-bit BGR pixel format that has no alpha-channel.  This format is common to some MSB configurations such as the one used by <i>LCL</i> in <i>Apple Carbon</i> interface. <br> <br>  I8 8-bit palette indexed format, where each value points to a list of colors, which was popular in DOS applications.  <br> <br> ", "tags": "", "loc": "PXL.Types.html#TPixelFormat"},
     {"title": "PXL.Types.TStandardNotifyEvent", "text": "    ", "tags": "", "loc": "PXL.Types.html#TStandardNotifyEvent"}
]};
